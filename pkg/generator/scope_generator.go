package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"strings"

	"github.com/shortontech/pickle/pkg/schema"
	"github.com/shortontech/pickle/pkg/tickle"
)

// GenerateQueryScopes produces a Go source file with typed Where*/With* methods
// for a given table, using scope templates parsed from the cooked scopes file.
func GenerateQueryScopes(table *schema.Table, blocks []tickle.ScopeBlock, packageName string) ([]byte, error) {
	columns := tickle.ColumnsFromTable(table)
	structName := tableToStructName(table.Name)
	scopeBody := tickle.GenerateScopes(blocks, columns, structName)

	// Collect imports needed by the generated scopes
	imports := collectScopeImports(table, blocks)

	var b bytes.Buffer
	b.WriteString("// Code generated by Pickle. DO NOT EDIT.\n")
	b.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	if len(imports) > 0 {
		b.WriteString("import (\n")
		for _, imp := range imports {
			b.WriteString(fmt.Sprintf("\t%q\n", imp))
		}
		b.WriteString(")\n\n")
	}

	// Generate the model-specific query wrapper type
	queryType := structName + "Query"
	b.WriteString(fmt.Sprintf("// %s provides typed query methods for %s.\n", queryType, structName))
	b.WriteString(fmt.Sprintf("type %s struct {\n\t*QueryBuilder[%s]\n}\n\n", queryType, structName))

	// Generate a typed Query constructor
	b.WriteString(fmt.Sprintf("// Query%s starts a new query for %s.\n", structName, structName))
	b.WriteString(fmt.Sprintf("func Query%s() *%s {\n", structName, queryType))
	b.WriteString(fmt.Sprintf("\treturn &%s{QueryBuilder: Query[%s]()}\n", queryType, structName))
	b.WriteString("}\n\n")

	// Generate eager loading methods from foreign keys
	for _, col := range table.Columns {
		if col.ForeignKeyTable != "" {
			relName := tableToStructName(col.ForeignKeyTable)
			b.WriteString(fmt.Sprintf("func (q *%s) With%s() *%s {\n", queryType, relName, queryType))
			b.WriteString(fmt.Sprintf("\tq.EagerLoad(%q)\n", col.ForeignKeyTable))
			b.WriteString(fmt.Sprintf("\treturn q\n"))
			b.WriteString("}\n\n")
		}
	}

	b.WriteString(scopeBody)

	formatted, err := format.Source(b.Bytes())
	if err != nil {
		return b.Bytes(), fmt.Errorf("go format: %w\n%s", err, b.String())
	}

	return formatted, nil
}

func collectScopeImports(table *schema.Table, blocks []tickle.ScopeBlock) []string {
	imports := map[string]bool{}

	// Check if any timestamp columns exist and timestamp scopes are used
	hasTimestamp := false
	hasUUID := false
	hasDecimal := false

	for _, col := range table.Columns {
		switch col.Type {
		case schema.Timestamp, schema.Date:
			hasTimestamp = true
		case schema.UUID:
			hasUUID = true
		case schema.Decimal:
			hasDecimal = true
		}
	}

	// Check if blocks reference these types
	for _, block := range blocks {
		if block.Scope == "timestamp" && hasTimestamp {
			imports["time"] = true
		}
	}

	// Always need these if columns of these types exist (for Where methods)
	if hasUUID {
		imports["github.com/google/uuid"] = true
	}
	if hasDecimal {
		imports["github.com/shopspring/decimal"] = true
	}
	if hasTimestamp {
		imports["time"] = true
	}

	var sorted []string
	for imp := range imports {
		sorted = append(sorted, imp)
	}

	// Stdlib first
	var std, ext []string
	for _, imp := range sorted {
		if strings.Contains(imp, ".") {
			ext = append(ext, imp)
		} else {
			std = append(std, imp)
		}
	}
	return append(std, ext...)
}
