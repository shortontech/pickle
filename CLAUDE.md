# CLAUDE.md â€” Pickle ğŸ¥’

> A salty web framework for sour artisans.

## What Is Pickle?

Pickle is a **code generation framework** for Go that gives you Laravel's developer experience with Go's deployment story. You write controllers, migrations, request classes, and middleware in a Laravel-like syntax â€” Pickle watches your project and generates all the boring Go boilerplate around them. The output is idiomatic Go. The input is not. That's the point.

**One sentence:** Write Laravel code in Go, deploy a single static binary with no runtime.

**The problem:** Go makes you write 200 lines to do what Laravel does in 3. Every Go project is 60% boilerplate and 40% the thing you actually care about. ORMs are all terrible. There's no real MVC framework. The community thinks this is a feature.

**The solution:** Pickle generates the boilerplate from your intent. You write what matters â€” controllers, migrations, validation rules, middleware â€” and `pickle --watch` generates models, query scopes, request bindings, and everything else. The generated code is plain Go. You can read it, debug it, `grep` it. It's not magic. It's just code you didn't have to type.

## Architecture

```
You Write (source of truth):          Pickle Generates (don't edit):
â”œâ”€â”€ routes.go                         â”œâ”€â”€ pickle_gen.go              â† Context, Response, Router, Middleware
â”œâ”€â”€ user_controller.go                â”œâ”€â”€ bindings_gen.go            â† request deserialization + validation
â”œâ”€â”€ post_controller.go                â”œâ”€â”€ models/
â”œâ”€â”€ create_user_request.go            â”‚   â”œâ”€â”€ pickle_gen.go          â† QueryBuilder[T], DB
â”œâ”€â”€ auth_middleware.go                â”‚   â”œâ”€â”€ user.go                â† struct from migration
â”œâ”€â”€ migrations/                       â”‚   â”œâ”€â”€ post.go                â† struct from migration
â”‚   â”œâ”€â”€ 001_create_users.go           â”‚   â”œâ”€â”€ user_query.go          â† WhereEmail(), WhereStatus(), etc.
â”‚   â””â”€â”€ 002_create_posts.go           â”‚   â””â”€â”€ post_query.go          â† WhereUserID(), WhereTitle(), etc.
â””â”€â”€ go.mod                            â””â”€â”€ migrations/
                                          â””â”€â”€ types_gen.go           â† Migration, Table, Column types
```

Everything lives in the project root as one flat Go package. Controllers, requests, middleware, and routes are all the same package â€” no cross-package import issues. Models live in `models/` as a separate package. Migrations live in `migrations/` with tickle-generated schema types.

**`pickle --watch`** scans for changes and regenerates. You never edit generated files â€” they get overwritten on the next run.

**The exit route:** If you stop using Pickle, all generated code still compiles. The generated output has zero dependency on Pickle. The only Pickle dependency is in `migrations/types_gen.go` â€” and even that is a self-contained copy of the schema types, not an import.

## Core Concepts

### Migrations â†’ Models

Migrations are the **single source of truth** for your database schema. You write them in Go using the schema DSL. Pickle generates model structs, query scope methods, and relationship helpers from them.

Migration files use Laravel-style naming: `{timestamp}_{description}.go`. The timestamp prefix determines execution order:

```go
// migrations/2026_02_21_143052_create_transfers_table.go
type CreateTransfersTable_2026_02_21_143052 struct {
    Migration
}

func (m *CreateTransfersTable_2026_02_21_143052) Up() {
    m.CreateTable("transfers", func(t *Table) {
        t.UUID("id").PrimaryKey().Default("uuid_generate_v7()")
        t.UUID("customer_id").NotNull().ForeignKey("customers", "id")
        t.String("status").NotNull().Default("pending")
        t.Decimal("amount", 18, 2).NotNull()
        t.String("currency", 3).NotNull()
        t.String("processor", 20).NotNull()
        t.String("brale_transfer_id", 255).Nullable()
        t.String("processor_order_id", 255).Nullable()
        t.JSONB("metadata").Nullable()
        t.Timestamps()
    })

    m.AddIndex("transfers", "customer_id")
    m.AddIndex("transfers", "status")
}

func (m *CreateTransfersTable_2026_02_21_143052) Down() {
    m.DropTableIfExists("transfers")
}
```

The `Migration`, `Table`, and `Column` types in the `migrations/` package are generated by tickle from `pkg/schema/` â€” they're self-contained copies with no import dependency on Pickle.

#### Migration Runner

Pickle scans the `migrations/` directory, sorts files by timestamp prefix, and generates a registry. The runner walks this slice, checks each against the `pickle_migrations` table, and executes pending ones.

#### Transactional Migrations

Migrations run inside a database transaction by default. If any statement fails, the entire migration rolls back â€” no half-applied state. DDL that can't be transactioned (e.g., `CREATE TABLE` on MySQL) runs outside the transaction, while DML and transaction-safe operations run inside it. The `Down()` method handles cleanup for non-transactional DDL (e.g., `DropTableIfExists` is idempotent).

On Postgres, which supports transactional DDL, the entire migration runs in one transaction. The runner is driver-aware â€” same migration code, different execution strategy.

For migrations that explicitly can't use transactions (e.g., `CREATE INDEX CONCURRENTLY` on Postgres):

```go
func (m *AddSearchIndex_2026_03_01_120000) Transactional() bool { return false }
```

#### Migration State Machine

Each migration tracks its lifecycle in the `pickle_migrations` table:

```
Pending â†’ Running â†’ Applied
              â†“
           Failed
Applied â†’ Rolling Back â†’ Rolled Back
              â†“
           Failed
```

States:
- **Pending** â€” exists on disk, hasn't run
- **Running** â€” currently executing (lock acquired)
- **Applied** â€” successfully completed
- **Failed** â€” errored out (transaction rolled back what it could, error recorded)
- **Rolling Back** â€” rollback in progress
- **Rolled Back** â€” successfully reversed

The runner acquires a database lock before transitioning to Running, preventing concurrent execution. If the process crashes and a migration is stuck in Running, the next run surfaces the issue clearly instead of silently skipping or re-running.

```go
// pickle_migrations table
m.CreateTable("pickle_migrations", func(t *Table) {
    t.String("id").PrimaryKey()          // "2026_02_21_143052_create_transfers_table"
    t.Integer("batch").NotNull()
    t.String("state").NotNull()          // pending, running, applied, failed, rolling_back, rolled_back
    t.Text("error").Nullable()
    t.Timestamp("started_at").Nullable()
    t.Timestamp("completed_at").Nullable()
})
```

Pickle generates:
```go
// models/transfer.go (GENERATED â€” DO NOT EDIT)
type Transfer struct {
    ID               uuid.UUID        `json:"id" db:"id"`
    CustomerID       uuid.UUID        `json:"customer_id" db:"customer_id"`
    Status           string           `json:"status" db:"status"`
    Amount           decimal.Decimal  `json:"amount" db:"amount"`
    Currency         string           `json:"currency" db:"currency"`
    Processor        string           `json:"processor" db:"processor"`
    BraleTransferID  *string          `json:"brale_transfer_id,omitempty" db:"brale_transfer_id"`
    ProcessorOrderID *string          `json:"processor_order_id,omitempty" db:"processor_order_id"`
    Metadata         *json.RawMessage `json:"metadata,omitempty" db:"metadata"`
    CreatedAt        time.Time        `json:"created_at" db:"created_at"`
    UpdatedAt        time.Time        `json:"updated_at" db:"updated_at"`
}
```

### Query Builder

Each model gets a typed query wrapper with generated scope methods. The generic `QueryBuilder[T]` handles SQL construction; model-specific `TransferQuery` wraps it with type-safe `Where*` and `With*` methods.

```go
// Generated query type
type TransferQuery struct {
    *QueryBuilder[Transfer]
}

func QueryTransfer() *TransferQuery { ... }

// Generated scope methods
func (q *TransferQuery) WhereID(id uuid.UUID) *TransferQuery { ... }
func (q *TransferQuery) WhereCustomerID(id uuid.UUID) *TransferQuery { ... }
func (q *TransferQuery) WhereStatus(status string) *TransferQuery { ... }
func (q *TransferQuery) WithCustomer() *TransferQuery { ... }

// CRUD â€” inherited from QueryBuilder[T]
func (q *QueryBuilder[T]) First() (*T, error) { ... }
func (q *QueryBuilder[T]) All() ([]T, error) { ... }
func (q *QueryBuilder[T]) Count() (int64, error) { ... }
func (q *QueryBuilder[T]) Create(t *T) error { ... }
func (q *QueryBuilder[T]) Update(t *T) error { ... }
```

Usage:
```go
// Find transfers by customer and status
transfers, err := models.QueryTransfer().
    WhereCustomerID(customerID).
    WhereStatus("pending").
    All()

// Find a specific transfer
transfer, err := models.QueryTransfer().
    WhereBraleTransferID("2xNL6PAF0cbcQHyjMQJ2RKRfbD9").
    First()

// Eager load relationships
user, err := models.QueryUser().
    WhereEmail(email).
    WithPosts().
    First()

// No more db.Where("stauts = ?", status) typos. Ever.
```

### Request Classes â†’ Validation + Deserialization

Request classes define what comes in, how it's validated, and what the controller receives. Pickle generates `BindXxxRequest()` functions that deserialize JSON and run validation.

You write:
```go
// create_transfer_request.go
type CreateTransferRequest struct {
    ExpectationID string `json:"expectation_id" validate:"required,uuid"`
    Amount        string `json:"amount" validate:"required,decimal,min=0.01"`
    Currency      string `json:"currency" validate:"required,oneof=USD EUR GBP"`
    Direction     string `json:"direction" validate:"required,oneof=onramp offramp"`
}
```

Pickle generates `BindCreateTransferRequest(r *http.Request) (CreateTransferRequest, *BindingError)` with JSON deserialization, struct validation, and human-readable error messages.

### Controllers

Controllers are plain Go structs with value receivers. All handlers take `*Context` and return `Response`. Controllers that need request binding call the generated `Bind` function themselves.

```go
// transfer_controller.go
type TransferController struct {
    Controller
}

func (c TransferController) Store(ctx *Context) Response {
    req, bindErr := BindCreateTransferRequest(ctx.Request())
    if bindErr != nil {
        return ctx.JSON(bindErr.Status, bindErr)
    }

    transfer := &models.Transfer{
        CustomerID: uuid.MustParse(ctx.Auth().UserID),
        Amount:     decimal.RequireFromString(req.Amount),
        Currency:   req.Currency,
        Status:     "pending_approval",
    }

    if err := models.QueryTransfer().Create(transfer); err != nil {
        return ctx.Error(err)
    }

    return ctx.JSON(201, transfer)
}

func (c TransferController) Show(ctx *Context) Response {
    transfer, err := models.QueryTransfer().
        WhereID(uuid.MustParse(ctx.Param("id"))).
        First()

    if err != nil {
        return ctx.NotFound("transfer not found")
    }

    return ctx.JSON(200, transfer)
}

func (c TransferController) Index(ctx *Context) Response {
    transfers, err := models.QueryTransfer().
        WhereCustomerID(uuid.MustParse(ctx.Auth().UserID)).
        All()

    if err != nil {
        return ctx.Error(err)
    }

    return ctx.JSON(200, transfers)
}
```

### Routes

Routes are defined in a central `routes.go` file. The `Router` type is both a descriptor and a runtime router â€” it collects route definitions and registers them directly onto `net/http.ServeMux` via `RegisterRoutes()`. No code generation needed for routing.

```go
// routes.go
var API = Routes(func(r *Router) {
    r.Group("/api", RateLimit, func(r *Router) {
        r.Post("/auth/login", AuthController{}.Login)

        r.Group("/transfers", Auth, RequireKYB, func(r *Router) {
            r.Get("/", TransferController{}.Index)
            r.Get("/:id", TransferController{}.Show)
            r.Post("/", TransferController{}.Store)
        })

        r.Group("/admin", Auth, RequireRole("admin"), func(r *Router) {
            r.Resource("/users", UserController{})
        })
    })
})
```

Wire it up in main:
```go
func main() {
    mux := http.NewServeMux()
    API.RegisterRoutes(mux)
    http.ListenAndServe(":8080", mux)
}
```

Key features:
- **Groups** with shared prefixes and middleware that cascade to all child routes
- **Per-route middleware** passed as additional arguments after the handler
- **`r.Resource()`** registers standard CRUD routes (Index, Show, Store, Update, Destroy) for controllers that implement `ResourceController`
- **One file, whole app** â€” open `routes.go` and see every endpoint, its middleware, and its grouping
- **No code generation** â€” the Router handles registration at runtime using Go 1.22+ `ServeMux` patterns

### Middleware Stack

Middleware uses a simple function signature. Each middleware explicitly calls `next()` to continue the chain, or returns early to short-circuit it.

```go
// auth_middleware.go
func Auth(ctx *Context, next func() Response) Response {
    token := ctx.BearerToken()
    if token == "" {
        return ctx.Unauthorized("missing token")
    }

    claims, err := ValidateJWT(token)
    if err != nil {
        return ctx.Unauthorized("invalid token")
    }

    ctx.SetAuth(claims)
    return next()
}
```

Parameterized middleware returns a `MiddlewareFunc`:

```go
func RequireRole(roles ...string) MiddlewareFunc {
    return func(ctx *Context, next func() Response) Response {
        if !slices.Contains(roles, ctx.Auth().Role) {
            return ctx.Forbidden("insufficient permissions")
        }
        return next()
    }
}
```

Middleware can also do post-processing since it receives the `Response` from `next()`:

```go
func RequestTimer(ctx *Context, next func() Response) Response {
    start := time.Now()
    resp := next()
    resp.Header("X-Request-Duration", time.Since(start).String())
    return resp
}
```

The stack executes as nested calls. Group middleware runs first (outermost), then per-route middleware, then the controller:

```
Request â†’ RateLimit â†’ Auth â†’ RequireKYB â†’ Controller â†’ Response
```

Any layer can return early. The response bubbles back up through the stack, hitting post-processing in each layer on the way out.

## Tickle â€” Generator of Generators

Tickle is Pickle's internal build tool. It takes Go source files from Pickle's own packages and turns them into embedded templates that the generator writes into user projects. Tickle runs at Pickle development time, not at user project generation time.

```bash
# Run from pickle repo root â€” no arguments
go run ./pkg/tickle/cmd/
```

This pre-generates three embedded templates in `pkg/generator/`:
- `embed_http.go` â€” Context, Response, Router, Middleware, Controller (from `pkg/cooked/`)
- `embed_query.go` â€” QueryBuilder[T] (from `pkg/cooked/query.go`)
- `embed_schema.go` â€” Migration, Table, Column types (from `pkg/schema/`)

Each template uses `__PACKAGE__` as a placeholder. At generation time, the generator does a simple string replace with the target package name and writes the file. No AST parsing, no runtime file I/O from Pickle's source tree.

**The exit route:** Because tickle copies Pickle's types into the user's project, the generated output has zero import dependency on Pickle. If you delete Pickle, your project still compiles.

## Project Structure

```
pickle/
â”œâ”€â”€ cmd/pickle/
â”‚   â””â”€â”€ main.go                    â† CLI entrypoint: pickle --watch, pickle generate
â”œâ”€â”€ pkg/
â”‚   â”œâ”€â”€ generator/
â”‚   â”‚   â”œâ”€â”€ generate.go            â† Main orchestrator
â”‚   â”‚   â”œâ”€â”€ core_generator.go      â† Writes pre-tickled templates with package substitution
â”‚   â”‚   â”œâ”€â”€ model_generator.go     â† Generates model structs from schema
â”‚   â”‚   â”œâ”€â”€ scope_generator.go     â† Generates typed query scopes (WhereX, WithX)
â”‚   â”‚   â”œâ”€â”€ binding_generator.go   â† Generates request deserialization + validation
â”‚   â”‚   â”œâ”€â”€ schema_inspector.go    â† Generates temp program to extract schema from migrations
â”‚   â”‚   â”œâ”€â”€ embed_http.go          â† PRE-TICKLED: Context, Response, Router, etc.
â”‚   â”‚   â”œâ”€â”€ embed_query.go         â† PRE-TICKLED: QueryBuilder[T]
â”‚   â”‚   â””â”€â”€ embed_schema.go        â† PRE-TICKLED: Migration, Table, Column
â”‚   â”œâ”€â”€ cooked/                    â† Source-of-truth Go types (tickled into templates)
â”‚   â”‚   â”œâ”€â”€ context.go
â”‚   â”‚   â”œâ”€â”€ response.go
â”‚   â”‚   â”œâ”€â”€ router.go
â”‚   â”‚   â”œâ”€â”€ middleware.go
â”‚   â”‚   â”œâ”€â”€ controller.go
â”‚   â”‚   â”œâ”€â”€ query.go
â”‚   â”‚   â””â”€â”€ scopes.go              â† Scope templates (pickle:scope directives)
â”‚   â”œâ”€â”€ tickle/                    â† Generator of generators
â”‚   â”‚   â”œâ”€â”€ tickle.go              â† Reads Go files, merges with package substitution
â”‚   â”‚   â”œâ”€â”€ scopes.go              â† Scope block parser and expander
â”‚   â”‚   â””â”€â”€ cmd/main.go            â† CLI: run `tickle` with no args from repo root
â”‚   â”œâ”€â”€ schema/                    â† Migration DSL types (source of truth for tickle)
â”‚   â”‚   â”œâ”€â”€ migration.go
â”‚   â”‚   â”œâ”€â”€ table.go
â”‚   â”‚   â”œâ”€â”€ column.go
â”‚   â”‚   â””â”€â”€ types.go
â”‚   â”œâ”€â”€ watcher/
â”‚   â”‚   â””â”€â”€ watcher.go             â† File system watcher for --watch mode
â”‚   â””â”€â”€ migration/                 â† Migration runner (not yet implemented)
â”œâ”€â”€ testdata/
â”‚   â””â”€â”€ basic-crud/                â† Test app: users, posts (compiles standalone)
â”‚       â”œâ”€â”€ routes.go
â”‚       â”œâ”€â”€ user_controller.go
â”‚       â”œâ”€â”€ post_controller.go
â”‚       â”œâ”€â”€ *_request.go
â”‚       â”œâ”€â”€ auth_middleware.go
â”‚       â”œâ”€â”€ migrations/
â”‚       â””â”€â”€ models/                â† Generated
â”œâ”€â”€ go.mod
â””â”€â”€ CLAUDE.md
```

## CLI Commands

```bash
pickle --watch           # Watch for changes, regenerate on save
pickle generate          # One-shot: generate all files
pickle migrate           # Run pending migrations
pickle migrate:rollback  # Rollback last migration batch
pickle migrate:status    # Show migration status
pickle make:controller   # Scaffold a new controller
pickle make:migration    # Scaffold a new migration
pickle make:request      # Scaffold a new request class
pickle make:middleware    # Scaffold a new middleware
```

## What Pickle Is NOT

- **Not a runtime framework** â€” Pickle is a build tool. The generated code uses Go's stdlib and has no dependency on Pickle. There's no Pickle process running in production.
- **Not opinionated about your database driver** â€” Uses `database/sql` under the hood. Bring your own driver (`pgx`, `lib/pq`, whatever).
- **Not magic** â€” All generated code is visible, readable, debuggable Go. No reflection at runtime. No interface{} soup. Just structs and methods.
- **Not trying to replace Go idioms** â€” The generated OUTPUT is idiomatic Go. The input (your controllers, migrations) is Laravel-flavored. Pickle is the translator between "how you think" and "how Go wants it."

## Security

Pickle makes the secure path the default and the insecure path impossible or visibly wrong.

### By Design â€” Structural Prevention

- **SQL injection** â€” impossible. `QueryBuilder[T]` generates parameterized queries. There's no API for string interpolation.
- **Mass assignment** â€” request structs define exactly which fields are accepted. POSTing `{"role": "admin"}` does nothing if `CreateUserRequest` doesn't have a `Role` field.
- **Validation bypass** â€” controllers call generated `Bind` functions that validate before returning the typed struct.

### By Review â€” One-File Audit

- **IDOR / broken access control** â€” open `routes.go`, see every endpoint and its middleware stack. Missing `Auth` or `RequireRole` is immediately visible.
- **Middleware gaps** â€” the central route file makes it obvious which endpoints are public and which are protected. A security review is a 30-second read.

### By Tooling â€” Standard Scanner Compatibility

Generated code is plain, idiomatic Go. `go vet`, `gosec`, `staticcheck`, Snyk, Semgrep â€” they all work on Pickle's output with zero configuration. No framework abstractions to unwrap, no `interface{}` soup, no runtime reflection. Security scanners see exactly what runs in production.

This is the advantage of code generation over runtime frameworks. A scanner can't reason about Goravel's magic method resolution or custom abstractions. It can reason about a struct, a function, and a parameterized query â€” because that's just Go.

## Design Decisions

### Why a central route file?

Go doesn't have decorators or annotations. A central route file (`routes.go`) means one file, entire app surface area visible at a glance. It's how Laravel does it (`web.php` / `api.php`), and it's idiomatic Go (just function calls). The `Router` type collects route definitions and registers them at runtime â€” no code generation needed for routing.

### Why migrations in Go instead of SQL?

1. Type-safe column definitions â€” `t.String("email").Unique()` vs `VARCHAR(255) UNIQUE`
2. Pickle runs migrations to extract schema and generate models â€” can't easily do that with raw SQL
3. Rollbacks are co-located with the up migration
4. Conditional logic if needed (`if postgres { ... } else if sqlite { ... }`)

### Generated files: where do they go?

Generated files live alongside user code in the project root (with `_gen.go` suffix) and in `models/`. Every generated file has a `// Code generated by Pickle. DO NOT EDIT.` header.

### Query builder: not a full ORM

Pickle generates typed query methods, not a full Eloquent clone. The query builder compiles to prepared statements with parameterized queries. No string interpolation. No SQL injection. Keep it simple, ship it, iterate.

## Dependencies (Minimal)

- `github.com/fsnotify/fsnotify` â€” File watching for `--watch`
- `github.com/go-playground/validator/v10` â€” Struct validation (in generated bindings)
- `github.com/shopspring/decimal` â€” Decimal types for financial math (in generated models)
- `github.com/google/uuid` â€” UUID support (in generated models)
- `database/sql` + `net/http` â€” Go stdlib, used by generated code

## Linting Generated Code

Go's linter will complain about unused functions in generated files. Solutions:
1. Add `//nolint` directives to generated file headers
2. Configure `golangci-lint` to exclude generated `_gen.go` files and `models/`
3. Use `_ = Transfer.Query().WhereMiddleName` if it makes you feel better (don't actually do this)

The unused functions cost nothing at runtime. They're bytes in a binary. Your binary is maybe 2MB bigger. Your development velocity is 10x faster. The math works out.

## LLM Context Efficiency

Pickle is designed to be legible to AI. A Pickle project compresses the information an LLM needs to be effective â€” what might take 50k tokens of context in a raw Go project becomes 2-3k tokens of actual signal.

### Why It Works

Convention over configuration means the LLM never has to search. Validation is in request structs. Business logic is in controllers. Routes are in `routes.go`. Every single time, no exceptions. The LLM doesn't need to *read* the project â€” it needs to *ask questions* about it.

- **Controllers are pure business logic** â€” no boilerplate to read past. 20 lines of intent, not 200 lines of wiring.
- **Request structs are self-documenting API contracts** â€” struct tags tell the LLM exactly what's accepted and how it's validated.
- **`routes.go` is the entire API surface** â€” one file, every endpoint, every middleware stack.
- **`QueryTransfer().WhereStatus("pending").All()`** â€” reads like a sentence. No query builder internals to understand.
- **Generated files never need to be read** â€” they're an implementation detail. The LLM works at the same abstraction level the developer works at.

### MCP Server Integration

A Pickle MCP server gives LLMs queryable access to the project without consuming context on source files:

- **`pickle schema:show transfers`** â€” returns the exact table structure. No reading migration files.
- **`pickle routes:list`** â€” every endpoint, its middleware, its request class. One call.
- **`pickle make:migration`**, **`pickle make:controller`** â€” the LLM scaffolds via tools, not by writing boilerplate.

LLMs are deeply trained on both Laravel and Go. Pickle sits at the intersection â€” the LLM already understands the intent (Laravel conventions) and the output (idiomatic Go). The framework is the bridge between two things the LLM already knows.

### Microservices Sweet Spot

Pickle microservices are small enough to fit entirely in context. A typical service â€” 3-5 controllers, a handful of migrations, one `routes.go` â€” is maybe 2-3k tokens. The LLM can hold the *complete* service in its head at once, not a summary. Combined with clear service boundaries and the MCP server, the workflow becomes: describe what you want â†’ LLM scaffolds the entire service â†’ review, tweak, deploy a static binary.

## Development

```bash
# Build the CLI
go build -o pickle ./cmd/pickle/

# Run tickle to regenerate embedded templates (after changing pkg/cooked/ or pkg/schema/)
go run ./pkg/tickle/cmd/

# Run tests
go test ./...

# Generate from a test project
go run ./cmd/pickle/ generate --project ./testdata/basic-crud/

# Run in watch mode
go run ./cmd/pickle/ --watch --project ./testdata/basic-crud/
```

## Philosophy

Go's community confused *simplicity* with *tedium*. They're not the same thing. Writing the same HTTP handler boilerplate for the 47th time isn't simple â€” it's wasteful. Manually syncing struct definitions to database schemas isn't explicit â€” it's error-prone.

Pickle takes the position that if boilerplate can be generated, it should be. The generated code is visible, readable, and idiomatic Go. You sacrifice nothing. You gain everything.

**Laravel DX. Go binary. No runtime. ğŸ¥’**
