// Code generated by tickle. DO NOT EDIT.
package generator

const embedMIGRATION = "// Code generated by Pickle. DO NOT EDIT.\npackage __PACKAGE__\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"strings\"\n)\n\n// MigrationIface is implemented by all migration structs via embedded Migration.\ntype MigrationIface interface {\n\tReset()\n\tUp()\n\tDown()\n\tGetOperations() []Operation\n\tTransactional() bool\n}\n\n// MigrationEntry pairs a string ID with a migration instance.\ntype MigrationEntry struct {\n\tID        string\n\tMigration MigrationIface\n}\n\n// MigrationStatus describes a migration's current state.\ntype MigrationStatus struct {\n\tID      string\n\tBatch   int\n\tApplied bool\n}\n\n// SQLGenerator converts schema operations to SQL for a specific driver.\ntype SQLGenerator interface {\n\tCreateTable(t *Table) string\n\tDropTableIfExists(name string) string\n\tAddColumn(table string, col *Column) string\n\tDropColumn(table, column string) string\n\tRenameColumn(table, oldName, newName string) string\n\tAddIndex(idx *Index) string\n\tRenameTable(oldName, newName string) string\n}\n\n// Runner executes migrations against a database.\ntype Runner struct {\n\tDB        *sql.DB\n\tDriver    string\n\tGenerator SQLGenerator\n}\n\n// NewRunner creates a Runner configured for the given driver.\nfunc NewRunner(db *sql.DB, driver string) *Runner {\n\tvar gen SQLGenerator\n\tswitch driver {\n\tcase \"pgsql\", \"postgres\":\n\t\tgen = &postgresGenerator{}\n\tcase \"mysql\":\n\t\tgen = &mysqlGenerator{}\n\tdefault:\n\t\tgen = &sqliteGenerator{}\n\t}\n\treturn &Runner{DB: db, Driver: driver, Generator: gen}\n}\n\nfunc (r *Runner) ensureMigrationsTable() error {\n\tvar q string\n\tswitch r.Driver {\n\tcase \"pgsql\", \"postgres\":\n\t\tq = `CREATE TABLE IF NOT EXISTS migrations (\n\t\t\tid        SERIAL PRIMARY KEY,\n\t\t\tmigration VARCHAR(255) NOT NULL,\n\t\t\tbatch     INTEGER NOT NULL\n\t\t)`\n\tdefault:\n\t\tq = `CREATE TABLE IF NOT EXISTS migrations (\n\t\t\tid        INTEGER PRIMARY KEY AUTOINCREMENT,\n\t\t\tmigration VARCHAR(255) NOT NULL,\n\t\t\tbatch     INTEGER NOT NULL\n\t\t)`\n\t}\n\t_, err := r.DB.Exec(q)\n\treturn err\n}\n\nfunc (r *Runner) acquireLock() error {\n\tif r.Driver == \"pgsql\" || r.Driver == \"postgres\" {\n\t\t_, err := r.DB.Exec(\"SELECT pg_advisory_lock(20260101)\")\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (r *Runner) releaseLock() {\n\tif r.Driver == \"pgsql\" || r.Driver == \"postgres\" {\n\t\tr.DB.Exec(\"SELECT pg_advisory_unlock(20260101)\") //nolint:errcheck\n\t}\n}\n\nfunc (r *Runner) applied() (map[string]int, error) {\n\trows, err := r.DB.Query(\"SELECT migration, batch FROM migrations\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\tm := map[string]int{}\n\tfor rows.Next() {\n\t\tvar id string\n\t\tvar batch int\n\t\tif err := rows.Scan(&id, &batch); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tm[id] = batch\n\t}\n\treturn m, rows.Err()\n}\n\nfunc (r *Runner) nextBatch(applied map[string]int) int {\n\tmax := 0\n\tfor _, b := range applied {\n\t\tif b > max {\n\t\t\tmax = b\n\t\t}\n\t}\n\treturn max + 1\n}\n\nfunc (r *Runner) placeholder(n int) string {\n\tif r.Driver == \"pgsql\" || r.Driver == \"postgres\" {\n\t\treturn fmt.Sprintf(\"$%d\", n)\n\t}\n\treturn \"?\"\n}\n\nfunc (r *Runner) execOps(ops []Operation, tx *sql.Tx) error {\n\tfor _, op := range ops {\n\t\tsqls := r.opsToSQL(op)\n\t\tfor _, q := range sqls {\n\t\t\tif q == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif tx != nil {\n\t\t\t\tif _, err := tx.Exec(q); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"executing %q: %w\", q, err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif _, err := r.DB.Exec(q); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"executing %q: %w\", q, err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (r *Runner) opsToSQL(op Operation) []string {\n\tswitch op.Type {\n\tcase OpCreateTable:\n\t\treturn []string{r.Generator.CreateTable(op.TableDef)}\n\tcase OpDropTableIfExists:\n\t\treturn []string{r.Generator.DropTableIfExists(op.Table)}\n\tcase OpRenameTable:\n\t\treturn []string{r.Generator.RenameTable(op.OldName, op.NewName)}\n\tcase OpAddColumn:\n\t\ttmp := &Table{}\n\t\top.ColumnDef(tmp)\n\t\tvar out []string\n\t\tfor _, col := range tmp.Columns {\n\t\t\tout = append(out, r.Generator.AddColumn(op.Table, col))\n\t\t}\n\t\treturn out\n\tcase OpDropColumn:\n\t\treturn []string{r.Generator.DropColumn(op.Table, op.ColumnName)}\n\tcase OpRenameColumn:\n\t\treturn []string{r.Generator.RenameColumn(op.Table, op.OldName, op.NewName)}\n\tcase OpAddIndex, OpAddUniqueIndex:\n\t\treturn []string{r.Generator.AddIndex(op.Index)}\n\t}\n\treturn nil\n}\n\nfunc (r *Runner) runMigration(m MigrationIface) error {\n\tm.Reset()\n\tm.Up()\n\tops := m.GetOperations()\n\tif m.Transactional() {\n\t\ttx, err := r.DB.Begin()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := r.execOps(ops, tx); err != nil {\n\t\t\ttx.Rollback() //nolint:errcheck\n\t\t\treturn err\n\t\t}\n\t\treturn tx.Commit()\n\t}\n\treturn r.execOps(ops, nil)\n}\n\nfunc (r *Runner) rollbackMigration(m MigrationIface) error {\n\tm.Reset()\n\tm.Down()\n\tops := m.GetOperations()\n\tif m.Transactional() {\n\t\ttx, err := r.DB.Begin()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := r.execOps(ops, tx); err != nil {\n\t\t\ttx.Rollback() //nolint:errcheck\n\t\t\treturn err\n\t\t}\n\t\treturn tx.Commit()\n\t}\n\treturn r.execOps(ops, nil)\n}\n\n// Migrate runs all pending migrations in order.\nfunc (r *Runner) Migrate(entries []MigrationEntry) error {\n\tif err := r.ensureMigrationsTable(); err != nil {\n\t\treturn fmt.Errorf(\"creating migrations table: %w\", err)\n\t}\n\tif err := r.acquireLock(); err != nil {\n\t\treturn fmt.Errorf(\"acquiring lock: %w\", err)\n\t}\n\tdefer r.releaseLock()\n\n\tapplied, err := r.applied()\n\tif err != nil {\n\t\treturn err\n\t}\n\tbatch := r.nextBatch(applied)\n\n\tran := 0\n\tfor _, entry := range entries {\n\t\tif _, ok := applied[entry.ID]; ok {\n\t\t\tcontinue\n\t\t}\n\t\tfmt.Printf(\"  migrating: %s\\n\", entry.ID)\n\t\tif err := r.runMigration(entry.Migration); err != nil {\n\t\t\treturn fmt.Errorf(\"migrating %s: %w\", entry.ID, err)\n\t\t}\n\t\tq := fmt.Sprintf(\n\t\t\t\"INSERT INTO migrations (migration, batch) VALUES (%s, %s)\",\n\t\t\tr.placeholder(1), r.placeholder(2),\n\t\t)\n\t\tif _, err := r.DB.Exec(q, entry.ID, batch); err != nil {\n\t\t\treturn fmt.Errorf(\"recording %s: %w\", entry.ID, err)\n\t\t}\n\t\tfmt.Printf(\"  migrated:  %s\\n\", entry.ID)\n\t\tran++\n\t}\n\tif ran == 0 {\n\t\tfmt.Println(\"  nothing to migrate\")\n\t}\n\treturn nil\n}\n\n// Rollback reverses the last batch of migrations.\nfunc (r *Runner) Rollback(entries []MigrationEntry) error {\n\tif err := r.ensureMigrationsTable(); err != nil {\n\t\treturn fmt.Errorf(\"creating migrations table: %w\", err)\n\t}\n\tif err := r.acquireLock(); err != nil {\n\t\treturn fmt.Errorf(\"acquiring lock: %w\", err)\n\t}\n\tdefer r.releaseLock()\n\n\tapplied, err := r.applied()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tmaxBatch := 0\n\tfor _, b := range applied {\n\t\tif b > maxBatch {\n\t\t\tmaxBatch = b\n\t\t}\n\t}\n\tif maxBatch == 0 {\n\t\tfmt.Println(\"  nothing to roll back\")\n\t\treturn nil\n\t}\n\n\tfor i := len(entries) - 1; i >= 0; i-- {\n\t\tentry := entries[i]\n\t\tb, ok := applied[entry.ID]\n\t\tif !ok || b != maxBatch {\n\t\t\tcontinue\n\t\t}\n\t\tfmt.Printf(\"  rolling back: %s\\n\", entry.ID)\n\t\tif err := r.rollbackMigration(entry.Migration); err != nil {\n\t\t\treturn fmt.Errorf(\"rolling back %s: %w\", entry.ID, err)\n\t\t}\n\t\tq := fmt.Sprintf(\"DELETE FROM migrations WHERE migration = %s\", r.placeholder(1))\n\t\tif _, err := r.DB.Exec(q, entry.ID); err != nil {\n\t\t\treturn fmt.Errorf(\"removing %s: %w\", entry.ID, err)\n\t\t}\n\t\tfmt.Printf(\"  rolled back: %s\\n\", entry.ID)\n\t}\n\treturn nil\n}\n\n// Fresh drops all tables and re-runs all migrations.\nfunc (r *Runner) Fresh(entries []MigrationEntry) error {\n\tif err := r.ensureMigrationsTable(); err != nil {\n\t\treturn fmt.Errorf(\"creating migrations table: %w\", err)\n\t}\n\tif err := r.acquireLock(); err != nil {\n\t\treturn fmt.Errorf(\"acquiring lock: %w\", err)\n\t}\n\tdefer r.releaseLock()\n\n\tfmt.Println(\"  dropping all tables...\")\n\tfor i := len(entries) - 1; i >= 0; i-- {\n\t\tentry := entries[i]\n\t\tentry.Migration.Reset()\n\t\tentry.Migration.Down()\n\t\t// Best-effort â€” ignore errors (tables may not exist)\n\t\tr.execOps(entry.Migration.GetOperations(), nil) //nolint:errcheck\n\t\tentry.Migration.Reset()\n\t}\n\tr.DB.Exec(\"DROP TABLE IF EXISTS migrations\") //nolint:errcheck\n\n\t// Release lock before calling Migrate, which acquires its own\n\tr.releaseLock()\n\treturn r.Migrate(entries)\n}\n\n// Status returns the status of all known migrations.\nfunc (r *Runner) Status(entries []MigrationEntry) ([]MigrationStatus, error) {\n\tif err := r.ensureMigrationsTable(); err != nil {\n\t\treturn nil, fmt.Errorf(\"creating migrations table: %w\", err)\n\t}\n\tapplied, err := r.applied()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar result []MigrationStatus\n\tfor _, entry := range entries {\n\t\ts := MigrationStatus{ID: entry.ID}\n\t\tif batch, ok := applied[entry.ID]; ok {\n\t\t\ts.Applied = true\n\t\t\ts.Batch = batch\n\t\t}\n\t\tresult = append(result, s)\n\t}\n\treturn result, nil\n}\n\n// PrintStatus prints the migration status table to stdout.\nfunc PrintStatus(statuses []MigrationStatus) {\n\tmaxLen := 0\n\tfor _, s := range statuses {\n\t\tif len(s.ID) > maxLen {\n\t\t\tmaxLen = len(s.ID)\n\t\t}\n\t}\n\tfor _, s := range statuses {\n\t\tstate := \"Pending\"\n\t\tbatch := \"\"\n\t\tif s.Applied {\n\t\t\tstate = \"Applied\"\n\t\t\tbatch = fmt.Sprintf(\" (batch %d)\", s.Batch)\n\t\t}\n\t\tfmt.Printf(\"  %-*s  %s%s\\n\", maxLen, s.ID, state, batch)\n\t}\n}\n\ntype mysqlGenerator struct{}\n\nfunc (g *mysqlGenerator) CreateTable(t *Table) string {\n\tpanic(\"mysql migration generator not yet implemented\")\n}\n\nfunc (g *mysqlGenerator) DropTableIfExists(name string) string {\n\treturn fmt.Sprintf(\"DROP TABLE IF EXISTS `%s`\", name)\n}\n\nfunc (g *mysqlGenerator) AddColumn(table string, col *Column) string {\n\tpanic(\"mysql migration generator not yet implemented\")\n}\n\nfunc (g *mysqlGenerator) DropColumn(table, column string) string {\n\treturn fmt.Sprintf(\"ALTER TABLE `%s` DROP COLUMN `%s`\", table, column)\n}\n\nfunc (g *mysqlGenerator) RenameColumn(table, oldName, newName string) string {\n\treturn fmt.Sprintf(\"ALTER TABLE `%s` RENAME COLUMN `%s` TO `%s`\", table, oldName, newName)\n}\n\nfunc (g *mysqlGenerator) AddIndex(idx *Index) string {\n\tpanic(\"mysql migration generator not yet implemented\")\n}\n\nfunc (g *mysqlGenerator) RenameTable(oldName, newName string) string {\n\treturn fmt.Sprintf(\"RENAME TABLE `%s` TO `%s`\", oldName, newName)\n}\n\ntype postgresGenerator struct{}\n\n// qi quotes a Postgres identifier (table/column name).\nfunc qi(name string) string {\n\treturn `\"` + strings.ReplaceAll(name, `\"`, `\"\"`) + `\"`\n}\n\nfunc (g *postgresGenerator) CreateTable(t *Table) string {\n\tvar cols []string\n\tfor _, col := range t.Columns {\n\t\tcols = append(cols, g.columnDef(col))\n\t}\n\treturn fmt.Sprintf(\"CREATE TABLE %s (\\n\\t%s\\n)\", qi(t.Name), strings.Join(cols, \",\\n\\t\"))\n}\n\nfunc (g *postgresGenerator) columnDef(col *Column) string {\n\tvar b strings.Builder\n\tb.WriteString(qi(col.Name))\n\tb.WriteString(\" \")\n\tb.WriteString(g.columnType(col))\n\n\tif col.IsPrimaryKey {\n\t\tb.WriteString(\" PRIMARY KEY\")\n\t}\n\tif !col.IsNullable && !col.IsPrimaryKey {\n\t\tb.WriteString(\" NOT NULL\")\n\t}\n\tif col.IsUnique {\n\t\tb.WriteString(\" UNIQUE\")\n\t}\n\tif col.HasDefault {\n\t\tswitch v := col.DefaultValue.(type) {\n\t\tcase string:\n\t\t\t// Function calls (contain parens) pass through unquoted; string literals are quoted\n\t\t\tif strings.Contains(v, \"(\") {\n\t\t\t\tb.WriteString(fmt.Sprintf(\" DEFAULT %s\", v))\n\t\t\t} else {\n\t\t\t\tb.WriteString(fmt.Sprintf(\" DEFAULT '%s'\", v))\n\t\t\t}\n\t\tdefault:\n\t\t\tb.WriteString(fmt.Sprintf(\" DEFAULT %v\", v))\n\t\t}\n\t}\n\tif col.ForeignKeyTable != \"\" {\n\t\tb.WriteString(fmt.Sprintf(\" REFERENCES %s(%s)\", qi(col.ForeignKeyTable), qi(col.ForeignKeyColumn)))\n\t}\n\treturn b.String()\n}\n\nfunc (g *postgresGenerator) columnType(col *Column) string {\n\tswitch col.Type {\n\tcase UUID:\n\t\treturn \"UUID\"\n\tcase String:\n\t\tif col.Length > 0 {\n\t\t\treturn fmt.Sprintf(\"VARCHAR(%d)\", col.Length)\n\t\t}\n\t\treturn \"VARCHAR(255)\"\n\tcase Text:\n\t\treturn \"TEXT\"\n\tcase Integer:\n\t\treturn \"INTEGER\"\n\tcase BigInteger:\n\t\treturn \"BIGINT\"\n\tcase Decimal:\n\t\tif col.Precision > 0 {\n\t\t\treturn fmt.Sprintf(\"NUMERIC(%d, %d)\", col.Precision, col.Scale)\n\t\t}\n\t\treturn \"NUMERIC\"\n\tcase Boolean:\n\t\treturn \"BOOLEAN\"\n\tcase Timestamp:\n\t\treturn \"TIMESTAMPTZ\"\n\tcase JSONB:\n\t\treturn \"JSONB\"\n\tcase Date:\n\t\treturn \"DATE\"\n\tcase Time:\n\t\treturn \"TIME\"\n\tcase Binary:\n\t\treturn \"BYTEA\"\n\t}\n\treturn \"TEXT\"\n}\n\nfunc (g *postgresGenerator) DropTableIfExists(name string) string {\n\treturn fmt.Sprintf(\"DROP TABLE IF EXISTS %s CASCADE\", qi(name))\n}\n\nfunc (g *postgresGenerator) AddColumn(table string, col *Column) string {\n\treturn fmt.Sprintf(\"ALTER TABLE %s ADD COLUMN %s\", qi(table), g.columnDef(col))\n}\n\nfunc (g *postgresGenerator) DropColumn(table, column string) string {\n\treturn fmt.Sprintf(\"ALTER TABLE %s DROP COLUMN %s\", qi(table), qi(column))\n}\n\nfunc (g *postgresGenerator) RenameColumn(table, oldName, newName string) string {\n\treturn fmt.Sprintf(\"ALTER TABLE %s RENAME COLUMN %s TO %s\", qi(table), qi(oldName), qi(newName))\n}\n\nfunc (g *postgresGenerator) AddIndex(idx *Index) string {\n\tunique := \"\"\n\tif idx.Unique {\n\t\tunique = \"UNIQUE \"\n\t}\n\tidxName := fmt.Sprintf(\"%s_%s_idx\", idx.Table, strings.Join(idx.Columns, \"_\"))\n\tvar quotedCols []string\n\tfor _, c := range idx.Columns {\n\t\tquotedCols = append(quotedCols, qi(c))\n\t}\n\treturn fmt.Sprintf(\n\t\t\"CREATE %sINDEX IF NOT EXISTS %s ON %s (%s)\",\n\t\tunique, qi(idxName), qi(idx.Table), strings.Join(quotedCols, \", \"),\n\t)\n}\n\nfunc (g *postgresGenerator) RenameTable(oldName, newName string) string {\n\treturn fmt.Sprintf(\"ALTER TABLE %s RENAME TO %s\", qi(oldName), qi(newName))\n}\n\ntype sqliteGenerator struct{}\n\nfunc (g *sqliteGenerator) CreateTable(t *Table) string {\n\tpanic(\"sqlite migration generator not yet implemented\")\n}\n\nfunc (g *sqliteGenerator) DropTableIfExists(name string) string {\n\treturn fmt.Sprintf(`DROP TABLE IF EXISTS \"%s\"`, name)\n}\n\nfunc (g *sqliteGenerator) AddColumn(table string, col *Column) string {\n\tpanic(\"sqlite migration generator not yet implemented\")\n}\n\nfunc (g *sqliteGenerator) DropColumn(table, column string) string {\n\tpanic(\"sqlite: DROP COLUMN requires recreating the table\")\n}\n\nfunc (g *sqliteGenerator) RenameColumn(table, oldName, newName string) string {\n\treturn fmt.Sprintf(`ALTER TABLE \"%s\" RENAME COLUMN \"%s\" TO \"%s\"`, table, oldName, newName)\n}\n\nfunc (g *sqliteGenerator) AddIndex(idx *Index) string {\n\tpanic(\"sqlite migration generator not yet implemented\")\n}\n\nfunc (g *sqliteGenerator) RenameTable(oldName, newName string) string {\n\treturn fmt.Sprintf(`ALTER TABLE \"%s\" RENAME TO \"%s\"`, oldName, newName)\n}\n\n"
