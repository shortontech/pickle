package generator

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
)

// RequestDef describes a request struct parsed from the requests/ directory.
type RequestDef struct {
	Name   string         // e.g. CreateUserRequest
	Fields []RequestField // struct fields in order
}

// RequestField describes a single field in a request struct.
type RequestField struct {
	Name     string // Go field name
	Type     string // Go type as source string
	JSONTag  string // json struct tag value (e.g. "name")
	Validate string // validate struct tag value (e.g. "required,min=1,max=255")
}

// ScanRequests parses all Go files in a directory and extracts request struct definitions.
func ScanRequests(dir string) ([]RequestDef, error) {
	entries, err := os.ReadDir(dir)
	if err != nil {
		return nil, fmt.Errorf("reading requests dir: %w", err)
	}

	var requests []RequestDef

	for _, e := range entries {
		if e.IsDir() || !strings.HasSuffix(e.Name(), ".go") || strings.HasSuffix(e.Name(), "_test.go") {
			continue
		}

		path := filepath.Join(dir, e.Name())
		src, err := os.ReadFile(path)
		if err != nil {
			return nil, fmt.Errorf("reading %s: %w", path, err)
		}

		fset := token.NewFileSet()
		f, err := parser.ParseFile(fset, path, src, 0)
		if err != nil {
			return nil, fmt.Errorf("parsing %s: %w", path, err)
		}

		for _, decl := range f.Decls {
			gen, ok := decl.(*ast.GenDecl)
			if !ok || gen.Tok != token.TYPE {
				continue
			}

			for _, spec := range gen.Specs {
				ts, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}

				st, ok := ts.Type.(*ast.StructType)
				if !ok {
					continue
				}

				if !strings.HasSuffix(ts.Name.Name, "Request") {
					continue
				}

				req := RequestDef{Name: ts.Name.Name}

				for _, field := range st.Fields.List {
					if len(field.Names) == 0 {
						continue // embedded field
					}

					rf := RequestField{
						Name: field.Names[0].Name,
						Type: exprToTypeString(field.Type),
					}

					if field.Tag != nil {
						rf.JSONTag = extractTag(field.Tag.Value, "json")
						rf.Validate = extractTag(field.Tag.Value, "validate")
					}

					req.Fields = append(req.Fields, rf)
				}

				requests = append(requests, req)
			}
		}
	}

	sort.Slice(requests, func(i, j int) bool {
		return requests[i].Name < requests[j].Name
	})

	return requests, nil
}

// extractTag pulls a named tag value from a raw struct tag literal (including backticks).
func extractTag(rawTag, name string) string {
	// Strip backticks
	tag := strings.Trim(rawTag, "`")

	// Find name:"value"
	key := name + `:"`
	idx := strings.Index(tag, key)
	if idx < 0 {
		return ""
	}
	val := tag[idx+len(key):]
	end := strings.Index(val, `"`)
	if end < 0 {
		return ""
	}
	val = val[:end]

	// For json tags, strip options like ",omitempty"
	if name == "json" {
		if comma := strings.Index(val, ","); comma >= 0 {
			val = val[:comma]
		}
	}

	return val
}

// exprToTypeString renders an AST type expression to a Go source string.
func exprToTypeString(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.StarExpr:
		return "*" + exprToTypeString(t.X)
	case *ast.SelectorExpr:
		if pkg, ok := t.X.(*ast.Ident); ok {
			return pkg.Name + "." + t.Sel.Name
		}
	case *ast.ArrayType:
		return "[]" + exprToTypeString(t.Elt)
	case *ast.MapType:
		return "map[" + exprToTypeString(t.Key) + "]" + exprToTypeString(t.Value)
	}
	return "interface{}"
}

var bindingTemplate = template.Must(template.New("bindings").Funcs(template.FuncMap{
	"bt": func() string { return "`" },
}).Parse(bindingTemplateSource))

const bindingTemplateSource = `// Code generated by Pickle. DO NOT EDIT.
package {{ .Package }}

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strings"

	"github.com/go-playground/validator/v10"
)

var validate = validator.New()

// ValidationError represents a single field validation failure.
type ValidationError struct {
	Field   string {{ bt }}json:"field"{{ bt }}
	Message string {{ bt }}json:"message"{{ bt }}
}

// BindingError represents a request binding or validation failure.
type BindingError struct {
	Status int               {{ bt }}json:"-"{{ bt }}
	Errors []ValidationError {{ bt }}json:"errors"{{ bt }}
}

func (e *BindingError) Error() string {
	msgs := make([]string, len(e.Errors))
	for i, ve := range e.Errors {
		msgs[i] = ve.Field + ": " + ve.Message
	}
	return strings.Join(msgs, "; ")
}

func formatValidationErrors(err error) *BindingError {
	ve, ok := err.(validator.ValidationErrors)
	if !ok {
		return &BindingError{
			Status: 422,
			Errors: []ValidationError{{ "{{" }}Field: "_body", Message: err.Error()}},
		}
	}

	errors := make([]ValidationError, len(ve))
	for i, fe := range ve {
		errors[i] = ValidationError{
			Field:   toSnakeCase(fe.Field()),
			Message: formatFieldError(fe),
		}
	}

	return &BindingError{Status: 422, Errors: errors}
}

func formatFieldError(fe validator.FieldError) string {
	switch fe.Tag() {
	case "required":
		return "is required"
	case "email":
		return "must be a valid email address"
	case "min":
		return fmt.Sprintf("must be at least %s", fe.Param())
	case "max":
		return fmt.Sprintf("must be at most %s", fe.Param())
	case "oneof":
		return fmt.Sprintf("must be one of: %s", fe.Param())
	case "uuid":
		return "must be a valid UUID"
	case "required_if":
		return fmt.Sprintf("is required when %s", fe.Param())
	default:
		return fmt.Sprintf("failed %s validation", fe.Tag())
	}
}

func toSnakeCase(s string) string {
	var result []byte
	for i, c := range s {
		if c >= 'A' && c <= 'Z' {
			if i > 0 {
				result = append(result, '_')
			}
			result = append(result, byte(c+32))
		} else {
			result = append(result, byte(c))
		}
	}
	return string(result)
}
{{ range .Requests }}
// Bind{{ .Name }} deserializes and validates a {{ .Name }} from the HTTP request body.
func Bind{{ .Name }}(r *http.Request) ({{ .Name }}, *BindingError) {
	var req {{ .Name }}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		return req, &BindingError{
			Status: 400,
			Errors: []ValidationError{{ "{{" }}Field: "_body", Message: "invalid request body"}},
		}
	}
	if err := validate.Struct(req); err != nil {
		return req, formatValidationErrors(err)
	}
	return req, nil
}
{{ end -}}
`

type bindingTemplateData struct {
	Package  string
	Requests []RequestDef
}

// GenerateBindings produces a Go source file with Bind functions for each request struct.
func GenerateBindings(requests []RequestDef, packageName string) ([]byte, error) {
	data := bindingTemplateData{
		Package:  packageName,
		Requests: requests,
	}

	var buf bytes.Buffer
	if err := bindingTemplate.Execute(&buf, data); err != nil {
		return nil, fmt.Errorf("template execution: %w", err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("go format: %w\n---raw output---\n%s", err, buf.String())
	}

	return formatted, nil
}
