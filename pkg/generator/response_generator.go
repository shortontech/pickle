package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"sort"
	"strings"
	"text/template"

	"github.com/shortontech/pickle/pkg/schema"
)

var responseTemplate = template.Must(template.New("response").Parse(`// Code generated by Pickle. DO NOT EDIT.
package {{ .Package }}
{{ if .Imports }}
import (
{{- range .Imports }}
	"{{ . }}"
{{- end }}
)
{{ end }}
{{ range .Structs }}
// {{ .Name }} contains {{ .Description }}.
type {{ .Name }} struct {
{{- range .Fields }}
	{{ .Name }} {{ .Type }} ` + "`" + `json:"{{ .JSONTag }}"` + "`" + `
{{- end }}
}
{{ end }}
// Serialize{{ .ModelName }} picks the appropriate response struct based on ownership.
// If ownerID matches the row's owner column, returns {{ .ModelName }}OwnerResponse.
// Otherwise returns {{ .ModelName }}PublicResponse.
func Serialize{{ .ModelName }}(record *{{ .ModelName }}, ownerID string) any {
	if ownerID != "" && {{ .OwnerMatch }} {
		return {{ .ModelName }}OwnerResponse{
{{- range .OwnerFields }}
			{{ .Name }}: record.{{ .Name }},
{{- end }}
		}
	}
	return {{ .ModelName }}PublicResponse{
{{- range .PublicFields }}
		{{ .Name }}: record.{{ .Name }},
{{- end }}
	}
}

// Serialize{{ .ModelName }}s serializes a slice of {{ .ModelName }} records.
func Serialize{{ .ModelName }}s(records []{{ .ModelName }}, ownerID string) []any {
	result := make([]any, len(records))
	for i := range records {
		result[i] = Serialize{{ .ModelName }}(&records[i], ownerID)
	}
	return result
}
`))

type responseData struct {
	Package      string
	Imports      []string
	ModelName    string
	Structs      []responseStruct
	OwnerMatch   string // e.g. "record.CustomerID.String() == ownerID"
	OwnerFields  []fieldData
	PublicFields []fieldData
}

type responseStruct struct {
	Name        string
	Description string
	Fields      []fieldData
}

// HasOwnership returns true if the table has an IsOwner column and at least one
// Public or OwnerSees column.
func HasOwnership(table *schema.Table) bool {
	hasOwner := false
	hasVisibility := false
	for _, col := range table.Columns {
		if col.IsOwnerColumn {
			hasOwner = true
		}
		if col.IsPublic || col.IsOwnerSees {
			hasVisibility = true
		}
	}
	return hasOwner && hasVisibility
}

// GenerateResponses produces a Go source file with PublicResponse, OwnerResponse
// structs and Serialize functions for a table with ownership declared.
func GenerateResponses(table *schema.Table, packageName string) ([]byte, error) {
	structName := tableToStructName(table.Name)
	imports := map[string]bool{}

	var publicFields []fieldData
	var ownerFields []fieldData
	var ownerCol *schema.Column

	for _, col := range table.Columns {
		if col.IsOwnerColumn {
			ownerCol = col
		}

		goType := columnGoType(col)
		if imp := columnImport(col); imp != "" {
			// Only add import if the field appears in a response struct
			if col.IsPublic || col.IsOwnerSees {
				imports[imp] = true
			}
		}

		jsonTag := col.Name
		if col.IsNullable {
			jsonTag += ",omitempty"
		}

		fd := fieldData{
			Name:    snakeToPascal(col.Name),
			Type:    goType,
			JSONTag: jsonTag,
			DBTag:   col.Name,
		}

		if col.IsPublic {
			publicFields = append(publicFields, fd)
			ownerFields = append(ownerFields, fd)
		} else if col.IsOwnerSees {
			ownerFields = append(ownerFields, fd)
		}
	}

	if ownerCol == nil {
		return nil, fmt.Errorf("table %s has no IsOwner column", table.Name)
	}

	// Build the owner match expression
	ownerFieldName := snakeToPascal(ownerCol.Name)
	ownerMatch := buildOwnerMatch(ownerFieldName, ownerCol)

	// Need fmt import for the string conversion if UUID
	if ownerCol.Type == schema.UUID {
		// UUID.String() doesn't need an import, it's a method
	}

	var sortedImports []string
	for imp := range imports {
		sortedImports = append(sortedImports, imp)
	}
	sort.Strings(sortedImports)

	var stdImports, extImports []string
	for _, imp := range sortedImports {
		if strings.Contains(imp, ".") {
			extImports = append(extImports, imp)
		} else {
			stdImports = append(stdImports, imp)
		}
	}
	orderedImports := append(stdImports, extImports...)

	data := responseData{
		Package:   packageName,
		Imports:   orderedImports,
		ModelName: structName,
		Structs: []responseStruct{
			{
				Name:        structName + "PublicResponse",
				Description: "fields visible to anyone",
				Fields:      publicFields,
			},
			{
				Name:        structName + "OwnerResponse",
				Description: "fields visible to the resource owner",
				Fields:      ownerFields,
			},
		},
		OwnerMatch:   ownerMatch,
		OwnerFields:  ownerFields,
		PublicFields: publicFields,
	}

	var buf bytes.Buffer
	if err := responseTemplate.Execute(&buf, data); err != nil {
		return nil, fmt.Errorf("template execution: %w", err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("go format: %w\n%s", err, buf.String())
	}

	return formatted, nil
}

// buildOwnerMatch returns a Go expression comparing the owner column to ownerID string.
func buildOwnerMatch(fieldName string, col *schema.Column) string {
	switch col.Type {
	case schema.UUID:
		return fmt.Sprintf("record.%s.String() == ownerID", fieldName)
	case schema.Integer, schema.BigInteger:
		return fmt.Sprintf("fmt.Sprint(record.%s) == ownerID", fieldName)
	default:
		return fmt.Sprintf("record.%s == ownerID", fieldName)
	}
}
