// Code generated by Pickle. DO NOT EDIT.
package pickle

import (
	"fmt"
	"log"
	"os"
	"net/http"
	"strings"
	"github.com/google/uuid"
	"encoding/json"
	"regexp"
)

// Command represents a CLI subcommand that the compiled binary can run.
type Command interface {
	Name() string
	Description() string
	Run(args []string) error
}

// App is the application lifecycle manager. It handles initialization,
// command dispatch, and HTTP serving.
type App struct {
	commands map[string]Command
	initFn   func()
	serveFn  func()
}

// BuildApp creates a new App with the given init, serve, and command functions.
func BuildApp(initFn func(), serveFn func(), cmds ...Command) *App {
	a := &App{
		commands: make(map[string]Command),
		initFn:   initFn,
		serveFn:  serveFn,
	}
	for _, cmd := range cmds {
		a.commands[cmd.Name()] = cmd
	}
	return a
}

// Run initializes the app, then either dispatches a command or starts HTTP.
func (a *App) Run(args []string) {
	a.initFn()

	if len(args) > 0 {
		if cmd, ok := a.commands[args[0]]; ok {
			if err := cmd.Run(args[1:]); err != nil {
				log.Fatal(err)
			}
			return
		}
	}

	a.serveFn()
}

// PrintCommands prints available commands to stderr.
func (a *App) PrintCommands() {
	fmt.Fprintln(os.Stderr, "Available commands:")
	for name, cmd := range a.commands {
		fmt.Fprintf(os.Stderr, "  %-25s %s\n", name, cmd.Description())
	}
}

// AuthInfo holds authentication state set by middleware.
type AuthInfo struct {
	UserID string
	Role   string
	Claims any
}

// Context wraps an HTTP request and response, providing helpers for controllers and middleware.
type Context struct {
	request  *http.Request
	response http.ResponseWriter
	params   map[string]string
	auth     *AuthInfo
}

// NewContext creates a Context from an HTTP request/response pair.
func NewContext(w http.ResponseWriter, r *http.Request) *Context {
	return &Context{
		request:  r,
		response: w,
		params:   make(map[string]string),
	}
}

// Request returns the underlying *http.Request.
func (c *Context) Request() *http.Request {
	return c.request
}

// ResponseWriter returns the underlying http.ResponseWriter.
func (c *Context) ResponseWriter() http.ResponseWriter {
	return c.response
}

// Param returns a URL path parameter by name (e.g. :id).
func (c *Context) Param(name string) string {
	return c.params[name]
}

// SetParam sets a URL path parameter. Used by the generated route handler.
func (c *Context) SetParam(name, value string) {
	c.params[name] = value
}

// ParamUUID returns a URL path parameter parsed as a UUID.
func (c *Context) ParamUUID(name string) uuid.UUID {
	return uuid.MustParse(c.params[name])
}

// Query returns a query string parameter by name.
func (c *Context) Query(name string) string {
	return c.request.URL.Query().Get(name)
}

// BearerToken extracts the token from the Authorization: Bearer header.
func (c *Context) BearerToken() string {
	h := c.request.Header.Get("Authorization")
	if !strings.HasPrefix(h, "Bearer ") {
		return ""
	}
	return h[7:]
}

// SetAuth stores authentication info (called by auth middleware).
func (c *Context) SetAuth(claims any) {
	switch v := claims.(type) {
	case *AuthInfo:
		c.auth = v
	default:
		c.auth = &AuthInfo{Claims: v}
	}
}

// Auth returns the authenticated user info, or nil if not authenticated.
func (c *Context) Auth() *AuthInfo {
	return c.auth
}

// ResourceQuery is implemented by generated query types to support ctx.Resource().
// It fetches a single record and returns it serialized for the given owner.
type ResourceQuery interface {
	FetchResource(ownerID string) (any, error)
}

// ResourceListQuery is implemented by generated query types to support ctx.Resources().
// It fetches all matching records and returns them serialized for the given owner.
type ResourceListQuery interface {
	FetchResources(ownerID string) (any, error)
}

// Resource executes a query that returns a single record, serialized based on
// the authenticated user's ownership. Returns 404 if the record is not found.
func (c *Context) Resource(q ResourceQuery) Response {
	ownerID := ""
	if c.auth != nil {
		ownerID = c.auth.UserID
	}
	result, err := q.FetchResource(ownerID)
	if err != nil {
		return c.NotFound("not found")
	}
	return c.JSON(http.StatusOK, result)
}

// Resources executes a query that returns a collection of records, serialized
// based on the authenticated user's ownership.
func (c *Context) Resources(q ResourceListQuery) Response {
	ownerID := ""
	if c.auth != nil {
		ownerID = c.auth.UserID
	}
	result, err := q.FetchResources(ownerID)
	if err != nil {
		return c.Error(err)
	}
	return c.JSON(http.StatusOK, result)
}

// JSON returns a JSON response with the given status code and data.
func (c *Context) JSON(status int, data any) Response {
	return Response{
		StatusCode: status,
		Body:       data,
		Headers:    map[string]string{"Content-Type": "application/json"},
	}
}

// NoContent returns a 204 No Content response.
func (c *Context) NoContent() Response {
	return Response{StatusCode: http.StatusNoContent}
}

// Error returns a 500 Internal Server Error response.
func (c *Context) Error(err error) Response {
	return Response{
		StatusCode: http.StatusInternalServerError,
		Body:       map[string]string{"error": err.Error()},
		Headers:    map[string]string{"Content-Type": "application/json"},
	}
}

// NotFound returns a 404 response with a message.
func (c *Context) NotFound(msg string) Response {
	return Response{
		StatusCode: http.StatusNotFound,
		Body:       map[string]string{"error": msg},
		Headers:    map[string]string{"Content-Type": "application/json"},
	}
}

// Unauthorized returns a 401 response with a message.
func (c *Context) Unauthorized(msg string) Response {
	return Response{
		StatusCode: http.StatusUnauthorized,
		Body:       map[string]string{"error": msg},
		Headers:    map[string]string{"Content-Type": "application/json"},
	}
}

// Forbidden returns a 403 response with a message.
func (c *Context) Forbidden(msg string) Response {
	return Response{
		StatusCode: http.StatusForbidden,
		Body:       map[string]string{"error": msg},
		Headers:    map[string]string{"Content-Type": "application/json"},
	}
}

// Controller is the base type embedded by all controllers.
// It exists so the generator can identify controller types.
type Controller struct{}

// RunMiddleware executes a middleware stack around a handler.
// Middleware functions are called in order, each wrapping the next.
func RunMiddleware(ctx *Context, middleware []MiddlewareFunc, handler func() Response) Response {
	if len(middleware) == 0 {
		return handler()
	}

	// Build the chain from the inside out.
	next := handler
	for i := len(middleware) - 1; i >= 0; i-- {
		mw := middleware[i]
		inner := next
		next = func() Response {
			return mw(ctx, inner)
		}
	}

	return next()
}

// Response represents an HTTP response to be written.
type Response struct {
	StatusCode int
	Body       any
	Headers    map[string]string
}

// Header returns a copy of the response with an additional header set.
func (r Response) Header(key, value string) Response {
	if r.Headers == nil {
		r.Headers = make(map[string]string)
	}
	r.Headers[key] = value
	return r
}

// Write serializes the response to an http.ResponseWriter.
func (r Response) Write(w http.ResponseWriter) {
	for k, v := range r.Headers {
		w.Header().Set(k, v)
	}

	if r.Body == nil {
		if r.StatusCode == 0 {
			r.StatusCode = http.StatusNoContent
		}
		w.WriteHeader(r.StatusCode)
		return
	}

	if r.StatusCode == 0 {
		r.StatusCode = http.StatusOK
	}

	data, err := json.Marshal(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(`{"error":"internal server error"}`))
		return
	}

	if w.Header().Get("Content-Type") == "" {
		w.Header().Set("Content-Type", "application/json")
	}
	w.WriteHeader(r.StatusCode)
	w.Write(data)
}

// MiddlewareFunc is the signature for middleware functions.
type MiddlewareFunc func(ctx *Context, next func() Response) Response

// HandlerFunc is a resolved handler that takes a Context and returns a Response.
type HandlerFunc func(ctx *Context) Response

// Route describes a single registered route.
type Route struct {
	Method     string
	Path       string
	Handler    HandlerFunc
	Middleware []MiddlewareFunc
}

// Router collects route definitions. It is a descriptor, not a runtime router.
type Router struct {
	prefix     string
	middleware []MiddlewareFunc
	routes     []Route
	groups     []*Router
}

// Routes creates a new Router by invoking the given configuration function.
func Routes(fn func(r *Router)) *Router {
	r := &Router{}
	fn(r)
	return r
}

func (r *Router) addRoute(method, path string, handler HandlerFunc, mw []MiddlewareFunc) {
	r.routes = append(r.routes, Route{
		Method:     method,
		Path:       path,
		Handler:    handler,
		Middleware: mw,
	})
}

// Get registers a GET route.
func (r *Router) Get(path string, handler HandlerFunc, mw ...MiddlewareFunc) {
	r.addRoute("GET", path, handler, mw)
}

// Post registers a POST route.
func (r *Router) Post(path string, handler HandlerFunc, mw ...MiddlewareFunc) {
	r.addRoute("POST", path, handler, mw)
}

// Put registers a PUT route.
func (r *Router) Put(path string, handler HandlerFunc, mw ...MiddlewareFunc) {
	r.addRoute("PUT", path, handler, mw)
}

// Patch registers a PATCH route.
func (r *Router) Patch(path string, handler HandlerFunc, mw ...MiddlewareFunc) {
	r.addRoute("PATCH", path, handler, mw)
}

// Delete registers a DELETE route.
func (r *Router) Delete(path string, handler HandlerFunc, mw ...MiddlewareFunc) {
	r.addRoute("DELETE", path, handler, mw)
}

// Group creates a sub-router with a shared prefix and optional middleware.
func (r *Router) Group(prefix string, body func(*Router), mw ...MiddlewareFunc) {
	g := &Router{prefix: prefix, middleware: mw}
	body(g)
	r.groups = append(r.groups, g)
}

// Resource registers standard CRUD routes for a controller.
type ResourceController interface {
	Index(*Context) Response
	Show(*Context) Response
	Store(*Context) Response
	Update(*Context) Response
	Destroy(*Context) Response
}

func (r *Router) Resource(prefix string, c ResourceController, mw ...MiddlewareFunc) {
	r.addRoute("GET", prefix, c.Index, mw)
	r.addRoute("GET", prefix+"/:id", c.Show, mw)
	r.addRoute("POST", prefix, c.Store, mw)
	r.addRoute("PUT", prefix+"/:id", c.Update, mw)
	r.addRoute("DELETE", prefix+"/:id", c.Destroy, mw)
}

// AllRoutes returns a flattened list of all routes with prefixes and
// middleware fully resolved.
func (r *Router) AllRoutes() []Route {
	return r.collectRoutes("", nil)
}

func (r *Router) collectRoutes(parentPrefix string, parentMW []MiddlewareFunc) []Route {
	fullPrefix := parentPrefix + r.prefix
	combinedMW := append(append([]MiddlewareFunc{}, parentMW...), r.middleware...)

	var routes []Route
	for _, route := range r.routes {
		resolved := Route{
			Method:     route.Method,
			Path:       fullPrefix + route.Path,
			Handler:    route.Handler,
			Middleware: append(append([]MiddlewareFunc{}, combinedMW...), route.Middleware...),
		}
		routes = append(routes, resolved)
	}

	for _, g := range r.groups {
		routes = append(routes, g.collectRoutes(fullPrefix, combinedMW)...)
	}

	return routes
}

var paramPattern = regexp.MustCompile(`:(\w+)`)

// RegisterRoutes wires all routes onto the given ServeMux.
func (r *Router) RegisterRoutes(mux *http.ServeMux) {
	for _, route := range r.AllRoutes() {
		route := route // capture

		// Convert :param to Go 1.22+ {param}
		goPath := paramPattern.ReplaceAllString(route.Path, "{${1}}")

		// Extract param names
		var params []string
		for _, match := range paramPattern.FindAllStringSubmatch(route.Path, -1) {
			params = append(params, match[1])
		}

		pattern := route.Method + " " + goPath

		handler := func(w http.ResponseWriter, req *http.Request) {
			ctx := NewContext(w, req)
			for _, name := range params {
				ctx.SetParam(name, req.PathValue(name))
			}

			var mw []MiddlewareFunc
			if len(route.Middleware) > 0 {
				mw = route.Middleware
			}

			resp := RunMiddleware(ctx, mw, func() Response {
				return route.Handler(ctx)
			})
			resp.Write(w)
		}

		mux.HandleFunc(pattern, handler)

		// Register the opposite slash variant to prevent ServeMux 301 redirects
		// that strip headers (e.g. Authorization). Skip paths ending in path params.
		if !strings.HasSuffix(goPath, "}") {
			if strings.HasSuffix(goPath, "/") {
				trimmed := strings.TrimRight(goPath, "/")
				if trimmed != "" {
					mux.HandleFunc(route.Method+" "+trimmed, handler)
				}
			} else {
				mux.HandleFunc(route.Method+" "+goPath+"/", handler)
			}
		}
	}
}

// Convenience: register on http.DefaultServeMux
func (r *Router) ListenAndServe(addr string) error {
	mux := http.NewServeMux()
	r.RegisterRoutes(mux)
	return http.ListenAndServe(addr, mux)
}

// trimTrailingSlash normalizes paths.
func trimTrailingSlash(s string) string {
	if len(s) > 1 {
		return strings.TrimRight(s, "/")
	}
	return s
}

