// Code generated by tickle. DO NOT EDIT.
package generator

const embedHTTP = "// Code generated by Pickle. DO NOT EDIT.\npackage __PACKAGE__\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"net/http\"\n\t\"strings\"\n\t\"encoding/json\"\n\t\"regexp\"\n)\n\n// Command represents a CLI subcommand that the compiled binary can run.\ntype Command interface {\n\tName() string\n\tDescription() string\n\tRun(args []string) error\n}\n\n// App is the application lifecycle manager. It handles initialization,\n// command dispatch, and HTTP serving.\ntype App struct {\n\tcommands map[string]Command\n\tinitFn   func()\n\tserveFn  func()\n}\n\n// BuildApp creates a new App with the given init, serve, and command functions.\nfunc BuildApp(initFn func(), serveFn func(), cmds ...Command) *App {\n\ta := &App{\n\t\tcommands: make(map[string]Command),\n\t\tinitFn:   initFn,\n\t\tserveFn:  serveFn,\n\t}\n\tfor _, cmd := range cmds {\n\t\ta.commands[cmd.Name()] = cmd\n\t}\n\treturn a\n}\n\n// Run initializes the app, then either dispatches a command or starts HTTP.\nfunc (a *App) Run(args []string) {\n\ta.initFn()\n\n\tif len(args) > 0 {\n\t\tif cmd, ok := a.commands[args[0]]; ok {\n\t\t\tif err := cmd.Run(args[1:]); err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n\n\ta.serveFn()\n}\n\n// PrintCommands prints available commands to stderr.\nfunc (a *App) PrintCommands() {\n\tfmt.Fprintln(os.Stderr, \"Available commands:\")\n\tfor name, cmd := range a.commands {\n\t\tfmt.Fprintf(os.Stderr, \"  %-25s %s\\n\", name, cmd.Description())\n\t}\n}\n\n// AuthInfo holds authentication state set by middleware.\ntype AuthInfo struct {\n\tUserID string\n\tRole   string\n\tClaims any\n}\n\n// Context wraps an HTTP request and response, providing helpers for controllers and middleware.\ntype Context struct {\n\trequest  *http.Request\n\tresponse http.ResponseWriter\n\tparams   map[string]string\n\tauth     *AuthInfo\n}\n\n// NewContext creates a Context from an HTTP request/response pair.\nfunc NewContext(w http.ResponseWriter, r *http.Request) *Context {\n\treturn &Context{\n\t\trequest:  r,\n\t\tresponse: w,\n\t\tparams:   make(map[string]string),\n\t}\n}\n\n// Request returns the underlying *http.Request.\nfunc (c *Context) Request() *http.Request {\n\treturn c.request\n}\n\n// ResponseWriter returns the underlying http.ResponseWriter.\nfunc (c *Context) ResponseWriter() http.ResponseWriter {\n\treturn c.response\n}\n\n// Param returns a URL path parameter by name (e.g. :id).\nfunc (c *Context) Param(name string) string {\n\treturn c.params[name]\n}\n\n// SetParam sets a URL path parameter. Used by the generated route handler.\nfunc (c *Context) SetParam(name, value string) {\n\tc.params[name] = value\n}\n\n// Query returns a query string parameter by name.\nfunc (c *Context) Query(name string) string {\n\treturn c.request.URL.Query().Get(name)\n}\n\n// BearerToken extracts the token from the Authorization: Bearer header.\nfunc (c *Context) BearerToken() string {\n\th := c.request.Header.Get(\"Authorization\")\n\tif !strings.HasPrefix(h, \"Bearer \") {\n\t\treturn \"\"\n\t}\n\treturn h[7:]\n}\n\n// SetAuth stores authentication info (called by auth middleware).\nfunc (c *Context) SetAuth(claims any) {\n\tswitch v := claims.(type) {\n\tcase *AuthInfo:\n\t\tc.auth = v\n\tdefault:\n\t\tc.auth = &AuthInfo{Claims: v}\n\t}\n}\n\n// Auth returns the authenticated user info, or nil if not authenticated.\nfunc (c *Context) Auth() *AuthInfo {\n\treturn c.auth\n}\n\n// JSON returns a JSON response with the given status code and data.\nfunc (c *Context) JSON(status int, data any) Response {\n\treturn Response{\n\t\tStatusCode: status,\n\t\tBody:       data,\n\t\tHeaders:    map[string]string{\"Content-Type\": \"application/json\"},\n\t}\n}\n\n// NoContent returns a 204 No Content response.\nfunc (c *Context) NoContent() Response {\n\treturn Response{StatusCode: http.StatusNoContent}\n}\n\n// Error returns a 500 Internal Server Error response.\nfunc (c *Context) Error(err error) Response {\n\treturn Response{\n\t\tStatusCode: http.StatusInternalServerError,\n\t\tBody:       map[string]string{\"error\": err.Error()},\n\t\tHeaders:    map[string]string{\"Content-Type\": \"application/json\"},\n\t}\n}\n\n// NotFound returns a 404 response with a message.\nfunc (c *Context) NotFound(msg string) Response {\n\treturn Response{\n\t\tStatusCode: http.StatusNotFound,\n\t\tBody:       map[string]string{\"error\": msg},\n\t\tHeaders:    map[string]string{\"Content-Type\": \"application/json\"},\n\t}\n}\n\n// Unauthorized returns a 401 response with a message.\nfunc (c *Context) Unauthorized(msg string) Response {\n\treturn Response{\n\t\tStatusCode: http.StatusUnauthorized,\n\t\tBody:       map[string]string{\"error\": msg},\n\t\tHeaders:    map[string]string{\"Content-Type\": \"application/json\"},\n\t}\n}\n\n// Forbidden returns a 403 response with a message.\nfunc (c *Context) Forbidden(msg string) Response {\n\treturn Response{\n\t\tStatusCode: http.StatusForbidden,\n\t\tBody:       map[string]string{\"error\": msg},\n\t\tHeaders:    map[string]string{\"Content-Type\": \"application/json\"},\n\t}\n}\n\n// Controller is the base type embedded by all controllers.\n// It exists so the generator can identify controller types.\ntype Controller struct{}\n\n// RunMiddleware executes a middleware stack around a handler.\n// Middleware functions are called in order, each wrapping the next.\nfunc RunMiddleware(ctx *Context, middleware []MiddlewareFunc, handler func() Response) Response {\n\tif len(middleware) == 0 {\n\t\treturn handler()\n\t}\n\n\t// Build the chain from the inside out.\n\tnext := handler\n\tfor i := len(middleware) - 1; i >= 0; i-- {\n\t\tmw := middleware[i]\n\t\tinner := next\n\t\tnext = func() Response {\n\t\t\treturn mw(ctx, inner)\n\t\t}\n\t}\n\n\treturn next()\n}\n\n// Response represents an HTTP response to be written.\ntype Response struct {\n\tStatusCode int\n\tBody       any\n\tHeaders    map[string]string\n}\n\n// Header returns a copy of the response with an additional header set.\nfunc (r Response) Header(key, value string) Response {\n\tif r.Headers == nil {\n\t\tr.Headers = make(map[string]string)\n\t}\n\tr.Headers[key] = value\n\treturn r\n}\n\n// Write serializes the response to an http.ResponseWriter.\nfunc (r Response) Write(w http.ResponseWriter) {\n\tfor k, v := range r.Headers {\n\t\tw.Header().Set(k, v)\n\t}\n\n\tif r.Body == nil {\n\t\tif r.StatusCode == 0 {\n\t\t\tr.StatusCode = http.StatusNoContent\n\t\t}\n\t\tw.WriteHeader(r.StatusCode)\n\t\treturn\n\t}\n\n\tif r.StatusCode == 0 {\n\t\tr.StatusCode = http.StatusOK\n\t}\n\n\tdata, err := json.Marshal(r.Body)\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tw.Write([]byte(`{\"error\":\"internal server error\"}`))\n\t\treturn\n\t}\n\n\tif w.Header().Get(\"Content-Type\") == \"\" {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t}\n\tw.WriteHeader(r.StatusCode)\n\tw.Write(data)\n}\n\n// MiddlewareFunc is the signature for middleware functions.\ntype MiddlewareFunc func(ctx *Context, next func() Response) Response\n\n// HandlerFunc is a resolved handler that takes a Context and returns a Response.\ntype HandlerFunc func(ctx *Context) Response\n\n// Route describes a single registered route.\ntype Route struct {\n\tMethod     string\n\tPath       string\n\tHandler    HandlerFunc\n\tMiddleware []MiddlewareFunc\n}\n\n// Router collects route definitions. It is a descriptor, not a runtime router.\ntype Router struct {\n\tprefix     string\n\tmiddleware []MiddlewareFunc\n\troutes     []Route\n\tgroups     []*Router\n}\n\n// Routes creates a new Router by invoking the given configuration function.\nfunc Routes(fn func(r *Router)) *Router {\n\tr := &Router{}\n\tfn(r)\n\treturn r\n}\n\nfunc (r *Router) addRoute(method, path string, handler HandlerFunc, mw []MiddlewareFunc) {\n\tr.routes = append(r.routes, Route{\n\t\tMethod:     method,\n\t\tPath:       path,\n\t\tHandler:    handler,\n\t\tMiddleware: mw,\n\t})\n}\n\n// Get registers a GET route.\nfunc (r *Router) Get(path string, handler HandlerFunc, mw ...MiddlewareFunc) {\n\tr.addRoute(\"GET\", path, handler, mw)\n}\n\n// Post registers a POST route.\nfunc (r *Router) Post(path string, handler HandlerFunc, mw ...MiddlewareFunc) {\n\tr.addRoute(\"POST\", path, handler, mw)\n}\n\n// Put registers a PUT route.\nfunc (r *Router) Put(path string, handler HandlerFunc, mw ...MiddlewareFunc) {\n\tr.addRoute(\"PUT\", path, handler, mw)\n}\n\n// Patch registers a PATCH route.\nfunc (r *Router) Patch(path string, handler HandlerFunc, mw ...MiddlewareFunc) {\n\tr.addRoute(\"PATCH\", path, handler, mw)\n}\n\n// Delete registers a DELETE route.\nfunc (r *Router) Delete(path string, handler HandlerFunc, mw ...MiddlewareFunc) {\n\tr.addRoute(\"DELETE\", path, handler, mw)\n}\n\n// Group creates a sub-router with a shared prefix and optional middleware.\n// The last func(*Router) argument is the group body; all other arguments\n// before it are treated as MiddlewareFunc.\nfunc (r *Router) Group(prefix string, args ...any) {\n\tg := &Router{prefix: prefix}\n\n\tfor _, arg := range args {\n\t\tswitch v := arg.(type) {\n\t\tcase MiddlewareFunc:\n\t\t\tg.middleware = append(g.middleware, v)\n\t\tcase func(*Context, func() Response) Response:\n\t\t\tg.middleware = append(g.middleware, v)\n\t\tcase func(r *Router):\n\t\t\tv(g)\n\t\t}\n\t}\n\n\tr.groups = append(r.groups, g)\n}\n\n// Resource registers standard CRUD routes for a controller.\ntype ResourceController interface {\n\tIndex(*Context) Response\n\tShow(*Context) Response\n\tStore(*Context) Response\n\tUpdate(*Context) Response\n\tDestroy(*Context) Response\n}\n\nfunc (r *Router) Resource(prefix string, c ResourceController, mw ...MiddlewareFunc) {\n\tr.addRoute(\"GET\", prefix, c.Index, mw)\n\tr.addRoute(\"GET\", prefix+\"/:id\", c.Show, mw)\n\tr.addRoute(\"POST\", prefix, c.Store, mw)\n\tr.addRoute(\"PUT\", prefix+\"/:id\", c.Update, mw)\n\tr.addRoute(\"DELETE\", prefix+\"/:id\", c.Destroy, mw)\n}\n\n// AllRoutes returns a flattened list of all routes with prefixes and\n// middleware fully resolved.\nfunc (r *Router) AllRoutes() []Route {\n\treturn r.collectRoutes(\"\", nil)\n}\n\nfunc (r *Router) collectRoutes(parentPrefix string, parentMW []MiddlewareFunc) []Route {\n\tfullPrefix := parentPrefix + r.prefix\n\tcombinedMW := append(append([]MiddlewareFunc{}, parentMW...), r.middleware...)\n\n\tvar routes []Route\n\tfor _, route := range r.routes {\n\t\tresolved := Route{\n\t\t\tMethod:     route.Method,\n\t\t\tPath:       fullPrefix + route.Path,\n\t\t\tHandler:    route.Handler,\n\t\t\tMiddleware: append(append([]MiddlewareFunc{}, combinedMW...), route.Middleware...),\n\t\t}\n\t\troutes = append(routes, resolved)\n\t}\n\n\tfor _, g := range r.groups {\n\t\troutes = append(routes, g.collectRoutes(fullPrefix, combinedMW)...)\n\t}\n\n\treturn routes\n}\n\nvar paramPattern = regexp.MustCompile(`:(\\w+)`)\n\n// RegisterRoutes wires all routes onto the given ServeMux.\nfunc (r *Router) RegisterRoutes(mux *http.ServeMux) {\n\tfor _, route := range r.AllRoutes() {\n\t\troute := route // capture\n\n\t\t// Convert :param to Go 1.22+ {param}\n\t\tgoPath := paramPattern.ReplaceAllString(route.Path, \"{${1}}\")\n\n\t\t// Extract param names\n\t\tvar params []string\n\t\tfor _, match := range paramPattern.FindAllStringSubmatch(route.Path, -1) {\n\t\t\tparams = append(params, match[1])\n\t\t}\n\n\t\tpattern := route.Method + \" \" + goPath\n\n\t\tmux.HandleFunc(pattern, func(w http.ResponseWriter, req *http.Request) {\n\t\t\tctx := NewContext(w, req)\n\t\t\tfor _, name := range params {\n\t\t\t\tctx.SetParam(name, req.PathValue(name))\n\t\t\t}\n\n\t\t\tvar mw []MiddlewareFunc\n\t\t\tif len(route.Middleware) > 0 {\n\t\t\t\tmw = route.Middleware\n\t\t\t}\n\n\t\t\tresp := RunMiddleware(ctx, mw, func() Response {\n\t\t\t\treturn route.Handler(ctx)\n\t\t\t})\n\t\t\tresp.Write(w)\n\t\t})\n\t}\n}\n\n// Convenience: register on http.DefaultServeMux\nfunc (r *Router) ListenAndServe(addr string) error {\n\tmux := http.NewServeMux()\n\tr.RegisterRoutes(mux)\n\treturn http.ListenAndServe(addr, mux)\n}\n\n// trimTrailingSlash normalizes paths.\nfunc trimTrailingSlash(s string) string {\n\tif len(s) > 1 {\n\t\treturn strings.TrimRight(s, \"/\")\n\t}\n\treturn s\n}\n\n"
