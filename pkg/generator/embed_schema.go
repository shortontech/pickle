// Code generated by tickle. DO NOT EDIT.
package generator

const embedSCHEMA = `// Code generated by Pickle. DO NOT EDIT.
package __PACKAGE__

// Column represents a database column definition.
type Column struct {
	Name             string
	Type             ColumnType
	Length           int
	Precision        int
	Scale            int
	IsPrimaryKey     bool
	IsNullable       bool
	IsUnique         bool
	DefaultValue     any
	HasDefault       bool
	ForeignKeyTable  string
	ForeignKeyColumn string
	IsPublic         bool
	IsOwnerSees      bool
	IsOwnerColumn    bool
}

func (c *Column) PrimaryKey() *Column {
	c.IsPrimaryKey = true
	return c
}

func (c *Column) NotNull() *Column {
	c.IsNullable = false
	return c
}

func (c *Column) Nullable() *Column {
	c.IsNullable = true
	return c
}

func (c *Column) Unique() *Column {
	c.IsUnique = true
	return c
}

func (c *Column) Default(value any) *Column {
	c.DefaultValue = value
	c.HasDefault = true
	return c
}

func (c *Column) ForeignKey(table, column string) *Column {
	c.ForeignKeyTable = table
	c.ForeignKeyColumn = column
	return c
}

// Public marks this column as visible to anyone (no auth required).
func (c *Column) Public() *Column {
	c.IsPublic = true
	return c
}

// OwnerSees marks this column as visible only to the row's owner.
func (c *Column) OwnerSees() *Column {
	c.IsOwnerSees = true
	return c
}

// IsOwner marks this column as the ownership column for the table.
// The value of this column is compared against the authenticated user's ID
// to determine ownership. Only one column per table may be marked as owner.
func (c *Column) IsOwner() *Column {
	c.IsOwnerColumn = true
	return c
}

// Index represents a database index.
type Index struct {
	Table   string
	Columns []string
	Unique  bool
}

// TableOperation represents a schema change recorded by a migration.
type TableOperation int

const (
	OpCreateTable TableOperation = iota
	OpDropTableIfExists
	OpRenameTable
	OpAddColumn
	OpDropColumn
	OpRenameColumn
	OpAddIndex
	OpAddUniqueIndex
	OpCreateView
	OpDropView
)

// Operation records a single schema change.
type Operation struct {
	Type         TableOperation
	Table        string
	TableDef     *Table
	ViewDef      *View
	Index        *Index
	NewName      string // for rename operations
	OldName      string // for rename operations
	ColumnName   string // for drop/rename column
	ColumnDef    func(*Table)
}

// Migration is the base type embedded by all migration structs.
// It records schema operations for later execution or inspection.
type Migration struct {
	Operations []Operation
}

func (m *Migration) CreateTable(name string, fn func(*Table)) {
	t := &Table{Name: name}
	fn(t)
	m.Operations = append(m.Operations, Operation{
		Type:     OpCreateTable,
		Table:    name,
		TableDef: t,
	})
}

func (m *Migration) DropTableIfExists(name string) {
	m.Operations = append(m.Operations, Operation{
		Type:  OpDropTableIfExists,
		Table: name,
	})
}

func (m *Migration) RenameTable(oldName, newName string) {
	m.Operations = append(m.Operations, Operation{
		Type:    OpRenameTable,
		Table:   oldName,
		OldName: oldName,
		NewName: newName,
	})
}

func (m *Migration) AddColumn(table string, fn func(*Table)) {
	m.Operations = append(m.Operations, Operation{
		Type:      OpAddColumn,
		Table:     table,
		ColumnDef: fn,
	})
}

func (m *Migration) DropColumn(table, column string) {
	m.Operations = append(m.Operations, Operation{
		Type:       OpDropColumn,
		Table:      table,
		ColumnName: column,
	})
}

func (m *Migration) RenameColumn(table, oldName, newName string) {
	m.Operations = append(m.Operations, Operation{
		Type:       OpRenameColumn,
		Table:      table,
		ColumnName: oldName,
		OldName:    oldName,
		NewName:    newName,
	})
}

func (m *Migration) AddIndex(table string, columns ...string) {
	m.Operations = append(m.Operations, Operation{
		Type:  OpAddIndex,
		Table: table,
		Index: &Index{
			Table:   table,
			Columns: columns,
			Unique:  false,
		},
	})
}

func (m *Migration) AddUniqueIndex(table string, columns ...string) {
	m.Operations = append(m.Operations, Operation{
		Type:  OpAddUniqueIndex,
		Table: table,
		Index: &Index{
			Table:   table,
			Columns: columns,
			Unique:  true,
		},
	})
}

func (m *Migration) CreateView(name string, fn func(*View)) {
	v := &View{Name: name}
	fn(v)
	m.Operations = append(m.Operations, Operation{
		Type:    OpCreateView,
		Table:   name,
		ViewDef: v,
	})
}

func (m *Migration) DropView(name string) {
	m.Operations = append(m.Operations, Operation{
		Type:  OpDropView,
		Table: name,
	})
}

// Reset clears recorded operations so the migration struct can be reused.
func (m *Migration) Reset() {
	m.Operations = nil
}

// GetOperations returns the operations recorded by Up() or Down().
func (m *Migration) GetOperations() []Operation {
	return m.Operations
}

// Transactional returns true — migrations run in a transaction by default.
// Override in concrete migration structs to opt out.
func (m *Migration) Transactional() bool {
	return true
}

// Table collects column definitions for a database table.
type Table struct {
	Name    string
	Columns []*Column
}

func (t *Table) addColumn(name string, colType ColumnType) *Column {
	c := &Column{
		Name: name,
		Type: colType,
	}
	t.Columns = append(t.Columns, c)
	return c
}

func (t *Table) UUID(name string) *Column {
	return t.addColumn(name, UUID)
}

func (t *Table) String(name string, length ...int) *Column {
	c := t.addColumn(name, String)
	if len(length) > 0 {
		c.Length = length[0]
	} else {
		c.Length = 255
	}
	return c
}

func (t *Table) Text(name string) *Column {
	return t.addColumn(name, Text)
}

func (t *Table) Integer(name string) *Column {
	return t.addColumn(name, Integer)
}

func (t *Table) BigInteger(name string) *Column {
	return t.addColumn(name, BigInteger)
}

func (t *Table) Decimal(name string, precision, scale int) *Column {
	c := t.addColumn(name, Decimal)
	c.Precision = precision
	c.Scale = scale
	return c
}

func (t *Table) Boolean(name string) *Column {
	return t.addColumn(name, Boolean)
}

func (t *Table) Timestamp(name string) *Column {
	return t.addColumn(name, Timestamp)
}

func (t *Table) JSONB(name string) *Column {
	return t.addColumn(name, JSONB)
}

func (t *Table) Date(name string) *Column {
	return t.addColumn(name, Date)
}

func (t *Table) Time(name string) *Column {
	return t.addColumn(name, Time)
}

func (t *Table) Binary(name string) *Column {
	return t.addColumn(name, Binary)
}

// Timestamps adds created_at and updated_at columns with NOW() defaults.
func (t *Table) Timestamps() {
	t.addColumn("created_at", Timestamp).NotNull().Default("NOW()")
	t.addColumn("updated_at", Timestamp).NotNull().Default("NOW()")
}

// ColumnType represents the data type of a database column.
type ColumnType int

const (
	UUID ColumnType = iota
	String
	Text
	Integer
	BigInteger
	Decimal
	Boolean
	Timestamp
	JSONB
	Date
	Time
	Binary
)

var columnTypeNames = [...]string{
	UUID:       "uuid",
	String:     "string",
	Text:       "text",
	Integer:    "integer",
	BigInteger: "bigint",
	Decimal:    "decimal",
	Boolean:    "boolean",
	Timestamp:  "timestamp",
	JSONB:      "jsonb",
	Date:       "date",
	Time:       "time",
	Binary:     "binary",
}

func (t ColumnType) String() string {
	if int(t) < len(columnTypeNames) {
		return columnTypeNames[t]
	}
	return "unknown"
}

// View represents a database view definition.
type View struct {
	Name         string
	Sources      []ViewSource
	Columns      []*ViewColumn
	GroupByCols  []string
}

// ViewSource represents a table referenced by a view (FROM or JOIN).
type ViewSource struct {
	Table         string
	Alias         string
	JoinType      string // "" for FROM, "JOIN", "LEFT JOIN"
	JoinCondition string
}

// ViewColumn represents a column in a view's SELECT list.
type ViewColumn struct {
	Column                       // embedded — carries Name, Type, Precision, Scale, IsNullable
	SourceAlias  string          // e.g. "t" from "t.id"
	SourceColumn string          // e.g. "id" from "t.id"
	OutputAlias  string          // optional alias for the output column name
	RawExpr      string          // raw SQL expression (for SelectRaw)
}

// OutputName returns the column name as it appears in the view's output.
func (vc *ViewColumn) OutputName() string {
	if vc.OutputAlias != "" {
		return vc.OutputAlias
	}
	if vc.SourceColumn != "" {
		return vc.SourceColumn
	}
	return vc.Name
}

// From sets the primary source table for the view.
func (v *View) From(table, alias string) {
	v.Sources = append(v.Sources, ViewSource{
		Table: table,
		Alias: alias,
	})
}

// Join adds an INNER JOIN to the view.
func (v *View) Join(table, alias, on string) {
	v.Sources = append(v.Sources, ViewSource{
		Table:         table,
		Alias:         alias,
		JoinType:      "JOIN",
		JoinCondition: on,
	})
}

// LeftJoin adds a LEFT JOIN to the view.
func (v *View) LeftJoin(table, alias, on string) {
	v.Sources = append(v.Sources, ViewSource{
		Table:         table,
		Alias:         alias,
		JoinType:      "LEFT JOIN",
		JoinCondition: on,
	})
}

// Column adds a column reference from a source table.
// ref is "alias.column" (e.g. "t.id"). An optional second argument aliases the output.
func (v *View) Column(ref string, alias ...string) {
	srcAlias, srcCol := parseColumnRef(ref)
	vc := &ViewColumn{
		SourceAlias:  srcAlias,
		SourceColumn: srcCol,
	}
	// Default the Name to the source column; overridden by alias if provided
	vc.Name = srcCol
	if len(alias) > 0 {
		vc.OutputAlias = alias[0]
		vc.Name = alias[0]
	}
	v.Columns = append(v.Columns, vc)
}

// SelectRaw adds a computed column with a raw SQL expression.
// Returns the ViewColumn so the caller can chain type builder methods.
func (v *View) SelectRaw(name, expr string) *ViewColumn {
	vc := &ViewColumn{
		RawExpr: expr,
	}
	vc.Name = name
	v.Columns = append(v.Columns, vc)
	return vc
}

// GroupBy sets the GROUP BY columns.
func (v *View) GroupBy(columns ...string) {
	v.GroupByCols = columns
}

// --- Type builder methods on ViewColumn (for SelectRaw) ---

func (vc *ViewColumn) BigInteger() *ViewColumn {
	vc.Type = BigInteger
	return vc
}

func (vc *ViewColumn) IntegerType() *ViewColumn {
	vc.Type = Integer
	return vc
}

func (vc *ViewColumn) Decimal(precision, scale int) *ViewColumn {
	vc.Type = Decimal
	vc.Precision = precision
	vc.Scale = scale
	return vc
}

func (vc *ViewColumn) StringType(length ...int) *ViewColumn {
	vc.Type = String
	if len(length) > 0 {
		vc.Length = length[0]
	} else {
		vc.Length = 255
	}
	return vc
}

func (vc *ViewColumn) TextType() *ViewColumn {
	vc.Type = Text
	return vc
}

func (vc *ViewColumn) BooleanType() *ViewColumn {
	vc.Type = Boolean
	return vc
}

func (vc *ViewColumn) TimestampType() *ViewColumn {
	vc.Type = Timestamp
	return vc
}

func (vc *ViewColumn) UUIDType() *ViewColumn {
	vc.Type = UUID
	return vc
}

func (vc *ViewColumn) JSONBType() *ViewColumn {
	vc.Type = JSONB
	return vc
}

// parseColumnRef splits "alias.column" into parts.
func parseColumnRef(ref string) (alias, column string) {
	for i := 0; i < len(ref); i++ {
		if ref[i] == '.' {
			return ref[:i], ref[i+1:]
		}
	}
	return "", ref
}

`
