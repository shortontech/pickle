package generator

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"strings"
	"text/template"
)

// ScanCommands parses Go files in the commands directory and returns the names
// of exported types that implement the Command interface (Name(), Description(), Run([]string) error).
func ScanCommands(commandsDir string) ([]string, error) {
	entries, err := os.ReadDir(commandsDir)
	if err != nil {
		return nil, err
	}

	var commands []string

	for _, e := range entries {
		if e.IsDir() || !strings.HasSuffix(e.Name(), ".go") || strings.HasSuffix(e.Name(), "_test.go") {
			continue
		}
		// Skip generated files
		if strings.HasSuffix(e.Name(), "_gen.go") {
			continue
		}

		fset := token.NewFileSet()
		f, err := parser.ParseFile(fset, commandsDir+"/"+e.Name(), nil, 0)
		if err != nil {
			continue
		}

		commands = append(commands, findCommandTypes(f)...)
	}

	return commands, nil
}

// findCommandTypes returns exported type names that have Name() string,
// Description() string, and Run([]string) error methods declared in the file.
func findCommandTypes(f *ast.File) []string {
	// Collect all exported struct type names
	structNames := map[string]bool{}
	for _, decl := range f.Decls {
		gen, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}
		for _, spec := range gen.Specs {
			ts, ok := spec.(*ast.TypeSpec)
			if !ok || !ts.Name.IsExported() {
				continue
			}
			if _, ok := ts.Type.(*ast.StructType); ok {
				structNames[ts.Name.Name] = true
			}
		}
	}

	// Check which structs have all three methods
	methods := map[string]map[string]bool{} // type -> method set
	for _, decl := range f.Decls {
		fn, ok := decl.(*ast.FuncDecl)
		if !ok || fn.Recv == nil || len(fn.Recv.List) == 0 {
			continue
		}

		typeName := receiverTypeName(fn.Recv.List[0].Type)
		if typeName == "" || !structNames[typeName] {
			continue
		}

		switch fn.Name.Name {
		case "Name", "Description", "Run":
			if methods[typeName] == nil {
				methods[typeName] = map[string]bool{}
			}
			methods[typeName][fn.Name.Name] = true
		}
	}

	var result []string
	for name, ms := range methods {
		if ms["Name"] && ms["Description"] && ms["Run"] {
			result = append(result, name)
		}
	}
	return result
}

func receiverTypeName(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.StarExpr:
		if ident, ok := t.X.(*ast.Ident); ok {
			return ident.Name
		}
	}
	return ""
}

// ScanRouteVars scans Go files in routesDir for exported var declarations
// that call pickle.Routes(...) and returns their names (e.g. ["API"]).
func ScanRouteVars(routesDir string) ([]string, error) {
	entries, err := os.ReadDir(routesDir)
	if err != nil {
		return nil, err
	}

	var vars []string
	for _, e := range entries {
		if e.IsDir() || !strings.HasSuffix(e.Name(), ".go") || strings.HasSuffix(e.Name(), "_test.go") {
			continue
		}

		fset := token.NewFileSet()
		f, err := parser.ParseFile(fset, routesDir+"/"+e.Name(), nil, 0)
		if err != nil {
			continue
		}

		for _, decl := range f.Decls {
			gen, ok := decl.(*ast.GenDecl)
			if !ok {
				continue
			}
			for _, spec := range gen.Specs {
				vs, ok := spec.(*ast.ValueSpec)
				if !ok || len(vs.Names) == 0 || !vs.Names[0].IsExported() {
					continue
				}
				// Check if the value is a call to something ending in "Routes"
				if len(vs.Values) == 1 {
					if call, ok := vs.Values[0].(*ast.CallExpr); ok {
						funcName := ""
						switch fn := call.Fun.(type) {
						case *ast.Ident:
							funcName = fn.Name
						case *ast.SelectorExpr:
							funcName = fn.Sel.Name
						}
						if funcName == "Routes" {
							vars = append(vars, vs.Names[0].Name)
						}
					}
				}
			}
		}
	}
	return vars, nil
}

var commandsGlueTemplate = template.Must(template.New("commands").Parse(`// Code generated by Pickle. DO NOT EDIT.
package commands

import (
	"log"
	"net/http"

	pickle "{{ .HTTPImport }}"
	"{{ .ModelsImport }}"
	"{{ .MigrationsImport }}"
	"{{ .ConfigImport }}"
	"{{ .RoutesImport }}"
)

// migrateCommand runs pending migrations.
type migrateCommand struct{}

func (c migrateCommand) Name() string        { return "migrate" }
func (c migrateCommand) Description() string { return "Run pending migrations" }
func (c migrateCommand) Run(args []string) error {
	runner := migrations.NewRunner(models.DB, config.Database.Connection().Driver)
	return runner.Migrate(migrations.Registry)
}

// migrateRollbackCommand rolls back the last batch.
type migrateRollbackCommand struct{}

func (c migrateRollbackCommand) Name() string        { return "migrate:rollback" }
func (c migrateRollbackCommand) Description() string { return "Roll back the last migration batch" }
func (c migrateRollbackCommand) Run(args []string) error {
	runner := migrations.NewRunner(models.DB, config.Database.Connection().Driver)
	return runner.Rollback(migrations.Registry)
}

// migrateFreshCommand drops all tables and re-runs migrations.
type migrateFreshCommand struct{}

func (c migrateFreshCommand) Name() string        { return "migrate:fresh" }
func (c migrateFreshCommand) Description() string { return "Drop all tables and re-run all migrations" }
func (c migrateFreshCommand) Run(args []string) error {
	runner := migrations.NewRunner(models.DB, config.Database.Connection().Driver)
	return runner.Fresh(migrations.Registry)
}

// migrateStatusCommand shows migration status.
type migrateStatusCommand struct{}

func (c migrateStatusCommand) Name() string        { return "migrate:status" }
func (c migrateStatusCommand) Description() string { return "Show migration status" }
func (c migrateStatusCommand) Run(args []string) error {
	runner := migrations.NewRunner(models.DB, config.Database.Connection().Driver)
	statuses, err := runner.Status(migrations.Registry)
	if err != nil {
		return err
	}
	migrations.PrintStatus(statuses)
	return nil
}

// BuiltinCommands returns the built-in Pickle commands.
func BuiltinCommands() []pickle.Command {
	return []pickle.Command{
		migrateCommand{},
		migrateRollbackCommand{},
		migrateFreshCommand{},
		migrateStatusCommand{},
	}
}

// UserCommands returns user-defined commands.
func UserCommands() []pickle.Command {
	return []pickle.Command{
{{ range .UserCommands }}		{{ . }}{},
{{ end }}	}
}

// Commands returns all commands (built-in + user-defined).
func Commands() []pickle.Command {
	return append(BuiltinCommands(), UserCommands()...)
}

// NewApp creates the application with config, database, routes, and commands wired up.
func NewApp() *pickle.App {
	return pickle.BuildApp(
		func() {
			config.Init()
			models.DB = config.Database.Open()
		},
		func() {
			mux := http.NewServeMux()
{{ range .RouteVars }}			routes.{{ . }}.RegisterRoutes(mux)
{{ end }}			log.Printf("listening on :%s", config.App.Port)
			http.ListenAndServe(":"+config.App.Port, mux)
		},
		Commands()...,
	)
}
`))

// GenerateCommandsGlue produces app/commands/pickle_gen.go.
func GenerateCommandsGlue(modulePath string, migrationsRel string, userCommands []string, routeVars []string) ([]byte, error) {
	// Default to "API" if no route vars found
	if len(routeVars) == 0 {
		routeVars = []string{"API"}
	}

	data := struct {
		HTTPImport       string
		ModelsImport     string
		MigrationsImport string
		ConfigImport     string
		RoutesImport     string
		UserCommands     []string
		RouteVars        []string
	}{
		HTTPImport:       modulePath + "/app/http",
		ModelsImport:     modulePath + "/app/models",
		MigrationsImport: modulePath + "/" + migrationsRel,
		ConfigImport:     modulePath + "/config",
		RoutesImport:     modulePath + "/routes",
		UserCommands:     userCommands,
		RouteVars:        routeVars,
	}

	var buf bytes.Buffer
	if err := commandsGlueTemplate.Execute(&buf, data); err != nil {
		return nil, fmt.Errorf("commands template: %w", err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return buf.Bytes(), err
	}
	return formatted, nil
}
