// Code generated by tickle. DO NOT EDIT.
package generator

const embedAUTHJWT = "// Code generated by Pickle. DO NOT EDIT.\npackage __PACKAGE__\n\nimport (\n\t\"crypto/hmac\"\n\t\"crypto/sha256\"\n\t\"crypto/sha512\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"hash\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n\tpickle \"github.com/shortontech/pickle/pkg/cooked\"\n)\n\n// Driver implements JWT-based authentication using HMAC signing (HS256/HS384/HS512).\n// All crypto uses Go's stdlib â€” no third-party JWT library.\ntype Driver struct {\n\tsecret    string\n\tissuer    string\n\texpiry    int // seconds\n\talgorithm string\n}\n\n// NewDriver creates a JWT auth driver. Config is read from environment:\n//   - JWT_SECRET: HMAC signing key (required)\n//   - JWT_ISSUER: expected issuer claim (optional)\n//   - JWT_EXPIRY: token lifetime in seconds (default: 3600)\n//   - JWT_ALGORITHM: HS256, HS384, or HS512 (default: HS256)\nfunc NewDriver(env func(string, string) string) *Driver {\n\texpiry := 3600\n\tif v := env(\"JWT_EXPIRY\", \"\"); v != \"\" {\n\t\t// Simple atoi without importing strconv\n\t\tn := 0\n\t\tfor _, c := range v {\n\t\t\tif c >= '0' && c <= '9' {\n\t\t\t\tn = n*10 + int(c-'0')\n\t\t\t}\n\t\t}\n\t\tif n > 0 {\n\t\t\texpiry = n\n\t\t}\n\t}\n\n\treturn &Driver{\n\t\tsecret:    env(\"JWT_SECRET\", \"\"),\n\t\tissuer:    env(\"JWT_ISSUER\", \"\"),\n\t\texpiry:    expiry,\n\t\talgorithm: env(\"JWT_ALGORITHM\", \"HS256\"),\n\t}\n}\n\n// Claims represents standard + custom JWT claims.\ntype Claims struct {\n\tSubject   string         `json:\"sub,omitempty\"`\n\tIssuer    string         `json:\"iss,omitempty\"`\n\tExpiresAt int64          `json:\"exp,omitempty\"`\n\tIssuedAt  int64          `json:\"iat,omitempty\"`\n\tRole      string         `json:\"role,omitempty\"`\n\tExtra     map[string]any `json:\"-\"`\n}\n\n// Authenticate extracts the Bearer token from the request, validates it,\n// and returns AuthInfo on success.\nfunc (d *Driver) Authenticate(r *http.Request) (*pickle.AuthInfo, error) {\n\th := r.Header.Get(\"Authorization\")\n\tif !strings.HasPrefix(h, \"Bearer \") {\n\t\treturn nil, errors.New(\"missing bearer token\")\n\t}\n\ttoken := h[7:]\n\treturn d.ValidateToken(token)\n}\n\n// SignToken creates a signed JWT from the given claims.\nfunc (d *Driver) SignToken(claims Claims) (string, error) {\n\tif d.secret == \"\" {\n\t\treturn \"\", errors.New(\"jwt: secret not configured\")\n\t}\n\n\tnow := time.Now().Unix()\n\tif claims.IssuedAt == 0 {\n\t\tclaims.IssuedAt = now\n\t}\n\tif claims.ExpiresAt == 0 && d.expiry > 0 {\n\t\tclaims.ExpiresAt = now + int64(d.expiry)\n\t}\n\tif claims.Issuer == \"\" && d.issuer != \"\" {\n\t\tclaims.Issuer = d.issuer\n\t}\n\n\talg := d.algorithm\n\tif alg == \"\" {\n\t\talg = \"HS256\"\n\t}\n\n\theader := base64URLEncode([]byte(`{\"alg\":\"` + alg + `\",\"typ\":\"JWT\"}`))\n\n\tpayload, err := json.Marshal(claims)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tpayloadEnc := base64URLEncode(payload)\n\n\tsigningInput := header + \".\" + payloadEnc\n\tsig, err := hmacSign([]byte(signingInput), []byte(d.secret), alg)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn signingInput + \".\" + base64URLEncode(sig), nil\n}\n\n// ValidateToken parses and validates a JWT string, returning AuthInfo on success.\nfunc (d *Driver) ValidateToken(tokenStr string) (*pickle.AuthInfo, error) {\n\tif d.secret == \"\" {\n\t\treturn nil, errors.New(\"jwt: secret not configured\")\n\t}\n\n\tparts := strings.SplitN(tokenStr, \".\", 3)\n\tif len(parts) != 3 {\n\t\treturn nil, errors.New(\"jwt: malformed token\")\n\t}\n\n\t// Verify signature\n\tsigningInput := parts[0] + \".\" + parts[1]\n\tsig, err := base64URLDecode(parts[2])\n\tif err != nil {\n\t\treturn nil, errors.New(\"jwt: invalid signature encoding\")\n\t}\n\n\talg := d.algorithm\n\tif alg == \"\" {\n\t\talg = \"HS256\"\n\t}\n\tif !hmacVerify([]byte(signingInput), sig, []byte(d.secret), alg) {\n\t\treturn nil, errors.New(\"jwt: invalid signature\")\n\t}\n\n\t// Decode claims\n\tclaimsJSON, err := base64URLDecode(parts[1])\n\tif err != nil {\n\t\treturn nil, errors.New(\"jwt: invalid payload encoding\")\n\t}\n\tvar claims Claims\n\tif err := json.Unmarshal(claimsJSON, &claims); err != nil {\n\t\treturn nil, errors.New(\"jwt: invalid claims\")\n\t}\n\n\t// Check expiry\n\tif claims.ExpiresAt > 0 && time.Now().Unix() > claims.ExpiresAt {\n\t\treturn nil, errors.New(\"jwt: token expired\")\n\t}\n\n\t// Check issuer\n\tif d.issuer != \"\" && claims.Issuer != d.issuer {\n\t\treturn nil, errors.New(\"jwt: invalid issuer\")\n\t}\n\n\treturn &pickle.AuthInfo{\n\t\tUserID: claims.Subject,\n\t\tRole:   claims.Role,\n\t\tClaims: claims,\n\t}, nil\n}\n\n// --- internal helpers ---\n\nfunc hmacHashFunc(alg string) func() hash.Hash {\n\tswitch alg {\n\tcase \"HS384\":\n\t\treturn sha512.New384\n\tcase \"HS512\":\n\t\treturn sha512.New\n\tdefault:\n\t\treturn sha256.New\n\t}\n}\n\nfunc hmacSign(input, secret []byte, alg string) ([]byte, error) {\n\tmac := hmac.New(hmacHashFunc(alg), secret)\n\tmac.Write(input)\n\treturn mac.Sum(nil), nil\n}\n\nfunc hmacVerify(input, sig, secret []byte, alg string) bool {\n\texpected, _ := hmacSign(input, secret, alg)\n\treturn hmac.Equal(sig, expected)\n}\n\nfunc base64URLEncode(data []byte) string {\n\treturn strings.TrimRight(base64.URLEncoding.EncodeToString(data), \"=\")\n}\n\nfunc base64URLDecode(s string) ([]byte, error) {\n\tswitch len(s) % 4 {\n\tcase 2:\n\t\ts += \"==\"\n\tcase 3:\n\t\ts += \"=\"\n\t}\n\treturn base64.URLEncoding.DecodeString(s)\n}\n\n"
