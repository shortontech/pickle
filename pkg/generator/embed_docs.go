// Code generated by tickle. DO NOT EDIT.
package generator

const embedDOCS = "[\n  {\n    \"name\": \"Commands\",\n    \"description\": \"The CLI command system for your compiled binary. The generated `App` handles initialization, command dispatch, and HTTP serving.\",\n    \"content\": \"# Commands\\n\\nThe CLI command system for your compiled binary. The generated `App` handles initialization, command dispatch, and HTTP serving.\\n\\n## How it works\\n\\nYour `cmd/server/main.go` creates an `App` and calls `Run()`:\\n\\n```go\\nfunc main() {\\n    commands.NewApp().Run(os.Args[1:])\\n}\\n```\\n\\nWith no arguments, the app starts the HTTP server. With a command name, it dispatches to that command instead.\\n\\n## Built-in commands\\n\\nPickle generates these commands automatically:\\n\\n| Command | Description |\\n|---------|-------------|\\n| `migrate` | Run pending database migrations |\\n| `migrate:rollback` | Roll back the last migration batch |\\n| `migrate:fresh` | Drop all tables and re-run migrations |\\n| `migrate:status` | Show migration status |\\n\\nRun them via: `go run ./cmd/server/ migrate`\\n\\n## App lifecycle\\n\\nThe generated `NewApp()` function builds an `App` with:\\n\\n1. **Init function** — loads config, opens database connection, sets `models.DB`\\n2. **Serve function** — registers routes on a `ServeMux` and starts HTTP\\n3. **Commands** — migrate, rollback, etc.\\n\\n`App.Run(args)` calls init first, then either dispatches a command or starts serving.\\n\\n## Custom commands\\n\\nImplement the `Command` interface:\\n\\n```go\\ntype Command interface {\\n    Name() string\\n    Description() string\\n    Run(args []string) error\\n}\\n```\\n\\nRegister commands in the generated `NewApp()` by placing them in `app/commands/`.\\n\"\n  },\n  {\n    \"name\": \"Config\",\n    \"description\": \"Application configuration using environment variables with typed config structs. Follows the Laravel pattern of config files that return typed structs.\",\n    \"content\": \"# Config\\n\\nApplication configuration using environment variables with typed config structs. Follows the Laravel pattern of config files that return typed structs.\\n\\n## Writing config\\n\\n```go\\n// config/app.go\\npackage config\\n\\ntype AppConfig struct {\\n    Name  string\\n    Env   string\\n    Debug bool\\n    Port  string\\n    URL   string\\n}\\n\\nfunc app() AppConfig {\\n    return AppConfig{\\n        Name:  Env(\\\"APP_NAME\\\", \\\"myapp\\\"),\\n        Env:   Env(\\\"APP_ENV\\\", \\\"local\\\"),\\n        Debug: Env(\\\"APP_DEBUG\\\", \\\"true\\\") == \\\"true\\\",\\n        Port:  Env(\\\"APP_PORT\\\", \\\"8080\\\"),\\n        URL:   Env(\\\"APP_URL\\\", \\\"http://localhost:8080\\\"),\\n    }\\n}\\n```\\n\\n```go\\n// config/database.go\\npackage config\\n\\ntype DatabaseConfig struct {\\n    Default     string\\n    Connections map[string]ConnectionConfig\\n}\\n\\nfunc database() DatabaseConfig {\\n    return DatabaseConfig{\\n        Default: Env(\\\"DB_CONNECTION\\\", \\\"pgsql\\\"),\\n        Connections: map[string]ConnectionConfig{\\n            \\\"pgsql\\\": {\\n                Driver:   \\\"pgsql\\\",\\n                Host:     Env(\\\"DB_HOST\\\", \\\"127.0.0.1\\\"),\\n                Port:     Env(\\\"DB_PORT\\\", \\\"5432\\\"),\\n                Name:     Env(\\\"DB_DATABASE\\\", \\\"myapp\\\"),\\n                User:     Env(\\\"DB_USERNAME\\\", \\\"postgres\\\"),\\n                Password: Env(\\\"DB_PASSWORD\\\", \\\"\\\"),\\n            },\\n        },\\n    }\\n}\\n```\\n\\n## Conventions\\n\\n- Config files live in `config/`.\\n- Each file defines a config struct and an unexported function that returns it.\\n- The function name determines the config key: `app()` → `config.App()`, `database()` → `config.Database()`.\\n- Pickle generates `config/pickle_gen.go` with exported accessor functions.\\n\\n## Env helper\\n\\n`Env(key, fallback)` reads environment variables with a default fallback. On first call, it loads `.env` from the project root. Environment variables take precedence over `.env` values.\\n\\n```go\\nport := Env(\\\"APP_PORT\\\", \\\"8080\\\")\\n```\\n\\n## ConnectionConfig\\n\\nThe built-in `ConnectionConfig` type handles database connections:\\n\\n```go\\ntype ConnectionConfig struct {\\n    Driver   string  // \\\"pgsql\\\", \\\"mysql\\\", \\\"sqlite\\\"\\n    Host     string\\n    Port     string\\n    Name     string  // database name (or file path for sqlite)\\n    User     string\\n    Password string\\n}\\n```\\n\\nIt has a `DSN()` method that returns the driver-specific connection string, and is used by `OpenDB()` to establish the database connection at startup.\\n\\n## .env file\\n\\nThe `.env` file at your project root sets defaults for local development:\\n\\n```\\nAPP_NAME=myapp\\nAPP_ENV=local\\nAPP_PORT=8080\\nDB_HOST=127.0.0.1\\nDB_PORT=5432\\nDB_DATABASE=myapp\\nDB_USERNAME=postgres\\nDB_PASSWORD=secret\\n```\\n\\nLines starting with `#` are comments. Values can be quoted with single or double quotes.\\n\"\n  },\n  {\n    \"name\": \"Context\",\n    \"description\": \"The request context passed to every controller and middleware. Wraps the HTTP request/response and provides helpers for params, auth, and response building.\",\n    \"content\": \"# Context\\n\\nThe request context passed to every controller and middleware. Wraps the HTTP request/response and provides helpers for params, auth, and response building.\\n\\nEvery controller method receives `*pickle.Context` as its only argument and returns `pickle.Response`. Context is created automatically by the router — you never construct one yourself.\\n\\n## Reading input\\n\\n```go\\n// URL path parameter (e.g. /users/:id)\\nid := ctx.Param(\\\"id\\\")\\n\\n// Query string parameter (e.g. /users?page=2)\\npage := ctx.Query(\\\"page\\\")\\n\\n// Bearer token from Authorization header\\ntoken := ctx.BearerToken()\\n\\n// Raw *http.Request for anything else\\nreq := ctx.Request()\\n```\\n\\n## Authentication\\n\\nAuth middleware calls `ctx.SetAuth(claims)` to store the authenticated user. Controllers read it back with `ctx.Auth()`.\\n\\n```go\\n// In middleware:\\nctx.SetAuth(\\u0026pickle.AuthInfo{\\n    UserID: \\\"abc-123\\\",\\n    Role:   \\\"admin\\\",\\n    Claims: jwtClaims, // any type — your JWT struct, session, etc.\\n})\\n\\n// In controllers:\\nuserID := ctx.Auth().UserID\\nrole := ctx.Auth().Role\\nclaims := ctx.Auth().Claims // type-assert to your claims type\\n```\\n\\n`ctx.Auth()` returns `nil` if no auth middleware has run. The `AuthInfo` struct has three fields:\\n- `UserID string` — the user's ID\\n- `Role string` — the user's role\\n- `Claims any` — the raw claims object (JWT claims, session data, etc.)\\n\\nIf you pass an `*AuthInfo` directly to `SetAuth`, it's stored as-is. Any other type is wrapped in `AuthInfo{Claims: v}`.\\n\\n## Building responses\\n\\nContext provides convenience methods that return `pickle.Response`:\\n\\n```go\\n// JSON response with status code\\nreturn ctx.JSON(200, user)\\nreturn ctx.JSON(201, transfer)\\n\\n// Error responses\\nreturn ctx.Error(err)            // 500 + {\\\"error\\\": err.Error()}\\nreturn ctx.NotFound(\\\"not found\\\") // 404 + {\\\"error\\\": \\\"not found\\\"}\\nreturn ctx.Unauthorized(\\\"bad token\\\") // 401\\nreturn ctx.Forbidden(\\\"no access\\\")    // 403\\n\\n// No content\\nreturn ctx.NoContent() // 204, empty body\\n```\\n\\nAll JSON responses set `Content-Type: application/json` automatically.\\n\\n## Method reference\\n\\n| Method | Returns | Description |\\n|--------|---------|-------------|\\n| `Request()` | `*http.Request` | Underlying HTTP request |\\n| `ResponseWriter()` | `http.ResponseWriter` | Underlying response writer |\\n| `Param(name)` | `string` | URL path parameter by name |\\n| `Query(name)` | `string` | Query string parameter by name |\\n| `BearerToken()` | `string` | Token from `Authorization: Bearer` header |\\n| `SetAuth(claims)` | — | Store auth info (called by middleware) |\\n| `Auth()` | `*AuthInfo` | Retrieve auth info, nil if unauthenticated |\\n| `JSON(status, data)` | `Response` | JSON response |\\n| `NoContent()` | `Response` | 204 response |\\n| `Error(err)` | `Response` | 500 response |\\n| `NotFound(msg)` | `Response` | 404 response |\\n| `Unauthorized(msg)` | `Response` | 401 response |\\n| `Forbidden(msg)` | `Response` | 403 response |\\n\"\n  },\n  {\n    \"name\": \"Controller\",\n    \"description\": \"Plain Go structs with value receivers. Each handler method takes `*pickle.Context` and returns `pickle.Response`.\",\n    \"content\": \"# Controller\\n\\nPlain Go structs with value receivers. Each handler method takes `*pickle.Context` and returns `pickle.Response`.\\n\\n## Writing a controller\\n\\n```go\\n// app/http/controllers/user_controller.go\\npackage controllers\\n\\nimport (\\n    pickle \\\"myapp/app/http\\\"\\n    \\\"myapp/app/http/requests\\\"\\n    \\\"myapp/app/models\\\"\\n)\\n\\ntype UserController struct {\\n    pickle.Controller\\n}\\n\\nfunc (c UserController) Index(ctx *pickle.Context) pickle.Response {\\n    users, err := models.QueryUser().All()\\n    if err != nil {\\n        return ctx.Error(err)\\n    }\\n    return ctx.JSON(200, users)\\n}\\n\\nfunc (c UserController) Show(ctx *pickle.Context) pickle.Response {\\n    user, err := models.QueryUser().\\n        WhereID(uuid.MustParse(ctx.Param(\\\"id\\\"))).\\n        First()\\n    if err != nil {\\n        return ctx.NotFound(\\\"user not found\\\")\\n    }\\n    return ctx.JSON(200, user)\\n}\\n\\nfunc (c UserController) Store(ctx *pickle.Context) pickle.Response {\\n    req, bindErr := requests.BindCreateUserRequest(ctx.Request())\\n    if bindErr != nil {\\n        return ctx.JSON(bindErr.Status, bindErr)\\n    }\\n\\n    user := \\u0026models.User{\\n        Name:  req.Name,\\n        Email: req.Email,\\n    }\\n    if err := models.QueryUser().Create(user); err != nil {\\n        return ctx.Error(err)\\n    }\\n    return ctx.JSON(201, user)\\n}\\n```\\n\\n## Conventions\\n\\n- Embed `pickle.Controller` so the generator can identify controller types.\\n- Use **value receivers** (not pointer receivers): `func (c UserController)`, not `func (c *UserController)`.\\n- Controllers live in `app/http/controllers/`.\\n- One controller per resource, named `{Resource}Controller`.\\n- Standard methods: `Index`, `Show`, `Store`, `Update`, `Destroy`.\\n\\n## ResourceController\\n\\nTo use `r.Resource()` in routes, implement all five CRUD methods:\\n\\n```go\\ntype ResourceController interface {\\n    Index(*Context) Response\\n    Show(*Context) Response\\n    Store(*Context) Response\\n    Update(*Context) Response\\n    Destroy(*Context) Response\\n}\\n```\\n\\n## Request binding\\n\\nControllers that accept input call generated `Bind` functions from the `requests` package:\\n\\n```go\\nreq, bindErr := requests.BindCreateUserRequest(ctx.Request())\\nif bindErr != nil {\\n    return ctx.JSON(bindErr.Status, bindErr)\\n}\\n```\\n\\nThe `Bind` function deserializes JSON, validates all fields, and returns either the typed request struct or a `*BindingError` with status code and human-readable validation messages.\\n\\n## Controller location\\n\\nControllers live in `app/http/controllers/`. They import `pickle \\\"myapp/app/http\\\"` for the Context and Response types.\\n\"\n  },\n  {\n    \"name\": \"Getting Started\",\n    \"description\": \"Everything you need to go from zero to a running Pickle app.\",\n    \"content\": \"# Getting Started\\n\\nEverything you need to go from zero to a running Pickle app.\\n\\n## What Pickle does\\n\\nYou write controllers, migrations, request classes, and middleware in a Laravel-like syntax. Pickle watches your project and generates all the Go boilerplate — models, query builders, request bindings, config glue, and the app entrypoint. The output is plain Go. No runtime dependency, no reflection magic, just a static binary.\\n\\n## Creating a project\\n\\n```bash\\npickle create myapp --module github.com/you/myapp\\ncd myapp\\n```\\n\\nThis scaffolds the full directory structure:\\n\\n```\\nmyapp/\\n├── cmd/server/main.go          ← Binary entrypoint\\n├── config/\\n│   ├── app.go                  ← App config (name, port, debug)\\n│   └── database.go             ← DB connections\\n├── routes/web.go               ← All API routes in one file\\n├── app/\\n│   ├── http/\\n│   │   ├── controllers/        ← Your business logic\\n│   │   ├── middleware/          ← Auth, rate limiting, etc.\\n│   │   └── requests/           ← Input validation structs\\n│   └── models/                 ← Generated from migrations\\n├── database/migrations/        ← Schema definitions\\n├── .env                        ← Environment variables\\n└── go.mod\\n```\\n\\nPickle also runs the generator and `go mod tidy`, so the project compiles immediately.\\n\\n## The workflow\\n\\n1. **Write a migration** — define your database table\\n2. **Write a request class** — define what input you accept\\n3. **Write a controller** — handle the request, talk to the database\\n4. **Add a route** — wire the controller to a URL\\n5. **Run `pickle --watch`** — Pickle generates models, query builders, bindings, and everything else\\n\\nRepeat. The generated files update every time you save.\\n\\n## Step by step: adding a resource\\n\\n### 1. Migration\\n\\n```go\\n// database/migrations/2026_02_27_120000_create_posts_table.go\\npackage migrations\\n\\ntype CreatePostsTable_2026_02_27_120000 struct {\\n    Migration\\n}\\n\\nfunc (m *CreatePostsTable_2026_02_27_120000) Up() {\\n    m.CreateTable(\\\"posts\\\", func(t *Table) {\\n        t.UUID(\\\"id\\\").PrimaryKey().Default(\\\"gen_random_uuid()\\\")\\n        t.UUID(\\\"user_id\\\").NotNull().ForeignKey(\\\"users\\\", \\\"id\\\")\\n        t.String(\\\"title\\\").NotNull()\\n        t.Text(\\\"body\\\").NotNull()\\n        t.Timestamps()\\n    })\\n}\\n\\nfunc (m *CreatePostsTable_2026_02_27_120000) Down() {\\n    m.DropTableIfExists(\\\"posts\\\")\\n}\\n```\\n\\nPickle generates `models/post.go` with the struct and `models/post_query.go` with typed query methods like `WhereUserID()`, `WhereTitle()`, etc.\\n\\n### 2. Request class\\n\\n```go\\n// app/http/requests/create_post.go\\npackage requests\\n\\ntype CreatePostRequest struct {\\n    Title string `json:\\\"title\\\" validate:\\\"required,min=1,max=200\\\"`\\n    Body  string `json:\\\"body\\\" validate:\\\"required\\\"`\\n}\\n```\\n\\nPickle generates `requests.BindCreatePostRequest()` which deserializes JSON and validates in one call.\\n\\n### 3. Controller\\n\\n```go\\n// app/http/controllers/post_controller.go\\npackage controllers\\n\\nimport (\\n    pickle \\\"myapp/app/http\\\"\\n    \\\"myapp/app/http/requests\\\"\\n    \\\"myapp/app/models\\\"\\n    \\\"github.com/google/uuid\\\"\\n)\\n\\ntype PostController struct {\\n    pickle.Controller\\n}\\n\\nfunc (c PostController) Index(ctx *pickle.Context) pickle.Response {\\n    posts, err := models.QueryPost().All()\\n    if err != nil {\\n        return ctx.Error(err)\\n    }\\n    return ctx.JSON(200, posts)\\n}\\n\\nfunc (c PostController) Store(ctx *pickle.Context) pickle.Response {\\n    req, bindErr := requests.BindCreatePostRequest(ctx.Request())\\n    if bindErr != nil {\\n        return ctx.JSON(bindErr.Status, bindErr)\\n    }\\n\\n    post := \\u0026models.Post{\\n        UserID: uuid.MustParse(ctx.Auth().UserID),\\n        Title:  req.Title,\\n        Body:   req.Body,\\n    }\\n    if err := models.QueryPost().Create(post); err != nil {\\n        return ctx.Error(err)\\n    }\\n    return ctx.JSON(201, post)\\n}\\n```\\n\\n### 4. Route\\n\\n```go\\n// routes/web.go\\npackage routes\\n\\nimport (\\n    pickle \\\"myapp/app/http\\\"\\n    \\\"myapp/app/http/controllers\\\"\\n    \\\"myapp/app/http/middleware\\\"\\n)\\n\\nvar API = pickle.Routes(func(r *pickle.Router) {\\n    r.Group(\\\"/api\\\", func(r *pickle.Router) {\\n        r.Get(\\\"/posts\\\", controllers.PostController{}.Index)\\n\\n        r.Group(\\\"/posts\\\", func(r *pickle.Router) {\\n            r.Post(\\\"/\\\", controllers.PostController{}.Store)\\n        }, middleware.Auth)\\n    })\\n})\\n```\\n\\n### 5. Generate and run\\n\\n```bash\\npickle --watch          # regenerates on every save\\npickle migrate          # run pending migrations\\ngo run ./cmd/server/    # start the server\\n```\\n\\n## What you write vs. what Pickle generates\\n\\n**You write** (source of truth — never overwritten):\\n- `database/migrations/` — table definitions\\n- `app/http/controllers/` — business logic\\n- `app/http/requests/` — input validation\\n- `app/http/middleware/` — auth, rate limiting\\n- `routes/web.go` — API surface\\n- `config/` — app and database config\\n- `cmd/server/main.go` — entrypoint\\n\\n**Pickle generates** (overwritten on every run — don't edit):\\n- `app/models/*.go` — structs with `json`/`db` tags from migrations\\n- `app/models/*_query.go` — typed query builders (`WhereEmail()`, `WithPosts()`)\\n- `app/models/pickle_gen.go` — generic `QueryBuilder[T]`\\n- `app/http/pickle_gen.go` — `Context`, `Response`, `Router`, middleware types\\n- `app/http/requests/bindings_gen.go` — `Bind` functions for each request struct\\n- `app/commands/pickle_gen.go` — app lifecycle, CLI commands, migration runner\\n- `config/pickle_gen.go` — config accessors\\n- `database/migrations/*_gen.go` — schema types, migration registry, runner\\n\\n## Running migrations\\n\\n```bash\\ngo run ./cmd/server/ migrate           # run pending\\ngo run ./cmd/server/ migrate:rollback  # undo last batch\\ngo run ./cmd/server/ migrate:fresh     # drop everything, re-run all\\ngo run ./cmd/server/ migrate:status    # show what's applied\\n```\\n\\nOr via the pickle CLI: `pickle migrate`, `pickle migrate:rollback`, etc.\\n\\n## Environment variables\\n\\nConfiguration is driven by `.env` at your project root. The `Env(key, fallback)` helper loads it automatically. Environment variables always take precedence over `.env` values.\\n\\n```\\nAPP_PORT=8080\\nDB_HOST=127.0.0.1\\nDB_PORT=5432\\nDB_DATABASE=myapp\\nDB_USERNAME=postgres\\nDB_PASSWORD=secret\\n```\\n\\n## The exit route\\n\\nIf you stop using Pickle, everything still works. The generated code is plain Go with zero dependency on Pickle. Delete the `pickle` binary, stop running the generator, and your project compiles exactly as before. Edit the generated files directly if you want — they're yours now.\\n\"\n  },\n  {\n    \"name\": \"Middleware\",\n    \"description\": \"Functions that wrap controller handlers. Each middleware receives the context and a `next` function, and decides whether to continue the chain or return early.\",\n    \"content\": \"# Middleware\\n\\nFunctions that wrap controller handlers. Each middleware receives the context and a `next` function, and decides whether to continue the chain or return early.\\n\\n## Signature\\n\\n```go\\nfunc MyMiddleware(ctx *pickle.Context, next func() pickle.Response) pickle.Response\\n```\\n\\nThe type alias is `pickle.MiddlewareFunc`:\\n\\n```go\\ntype MiddlewareFunc func(ctx *Context, next func() Response) Response\\n```\\n\\n## Writing middleware\\n\\n**Basic auth check:**\\n\\n```go\\nfunc Auth(ctx *pickle.Context, next func() pickle.Response) pickle.Response {\\n    token := ctx.BearerToken()\\n    if token == \\\"\\\" {\\n        return ctx.Unauthorized(\\\"missing token\\\")\\n    }\\n\\n    claims, err := validateJWT(token)\\n    if err != nil {\\n        return ctx.Unauthorized(\\\"invalid token\\\")\\n    }\\n\\n    ctx.SetAuth(claims)\\n    return next()\\n}\\n```\\n\\n**Parameterized middleware** — return a `MiddlewareFunc`:\\n\\n```go\\nfunc RequireRole(roles ...string) pickle.MiddlewareFunc {\\n    return func(ctx *pickle.Context, next func() pickle.Response) pickle.Response {\\n        if !slices.Contains(roles, ctx.Auth().Role) {\\n            return ctx.Forbidden(\\\"insufficient permissions\\\")\\n        }\\n        return next()\\n    }\\n}\\n```\\n\\n**Post-processing** — inspect or modify the response:\\n\\n```go\\nfunc RequestTimer(ctx *pickle.Context, next func() pickle.Response) pickle.Response {\\n    start := time.Now()\\n    resp := next()\\n    return resp.Header(\\\"X-Request-Duration\\\", time.Since(start).String())\\n}\\n```\\n\\n## Applying middleware\\n\\n**To a group** — all routes in the group inherit it:\\n\\n```go\\nr.Group(\\\"/admin\\\", func(r *pickle.Router) {\\n    r.Get(\\\"/dashboard\\\", controllers.AdminController{}.Dashboard)\\n}, middleware.Auth, middleware.RequireRole(\\\"admin\\\"))\\n```\\n\\n**To a single route:**\\n\\n```go\\nr.Post(\\\"/transfer\\\", controllers.TransferController{}.Store, middleware.Auth)\\n```\\n\\n## Execution order\\n\\nMiddleware executes as nested calls. Group middleware runs first (outermost), then per-route middleware, then the controller:\\n\\n```\\nRequest → RateLimit → Auth → RequireRole → Controller → Response\\n```\\n\\nAny layer can short-circuit by returning without calling `next()`. The response bubbles back up through each layer.\\n\\n## Middleware location\\n\\nMiddleware files live in `app/http/middleware/`. They're plain Go — no code generation needed.\\n\"\n  },\n  {\n    \"name\": \"Migrations\",\n    \"description\": \"The single source of truth for your database schema. You write migrations using the schema DSL; Pickle generates model structs and query scopes from them.\",\n    \"content\": \"# Migrations\\n\\nThe single source of truth for your database schema. You write migrations using the schema DSL; Pickle generates model structs and query scopes from them.\\n\\n## Writing a migration\\n\\n```go\\n// database/migrations/2026_02_21_143052_create_users_table.go\\npackage migrations\\n\\ntype CreateUsersTable_2026_02_21_143052 struct {\\n    Migration\\n}\\n\\nfunc (m *CreateUsersTable_2026_02_21_143052) Up() {\\n    m.CreateTable(\\\"users\\\", func(t *Table) {\\n        t.UUID(\\\"id\\\").PrimaryKey().Default(\\\"uuid_generate_v7()\\\")\\n        t.String(\\\"name\\\").NotNull()\\n        t.String(\\\"email\\\").NotNull().Unique()\\n        t.String(\\\"password\\\").NotNull()\\n        t.Text(\\\"bio\\\").Nullable()\\n        t.Timestamps()\\n    })\\n\\n    m.AddIndex(\\\"users\\\", \\\"email\\\")\\n}\\n\\nfunc (m *CreateUsersTable_2026_02_21_143052) Down() {\\n    m.DropTableIfExists(\\\"users\\\")\\n}\\n```\\n\\n## Naming convention\\n\\nFiles use `{timestamp}_{description}.go`. The timestamp prefix determines execution order. The struct name matches: `{PascalDescription}_{timestamp}`.\\n\\nUse `pickle make:migration create_posts_table` to scaffold one (generates the timestamp automatically).\\n\\n## Column types\\n\\n| DSL method | SQL type | Go type |\\n|-----------|----------|---------|\\n| `t.UUID(name)` | UUID | `uuid.UUID` |\\n| `t.String(name)` | VARCHAR(255) | `string` |\\n| `t.String(name, 100)` | VARCHAR(100) | `string` |\\n| `t.Text(name)` | TEXT | `string` |\\n| `t.Integer(name)` | INTEGER | `int` |\\n| `t.BigInteger(name)` | BIGINT | `int64` |\\n| `t.Decimal(name, 18, 2)` | DECIMAL(18,2) | `decimal.Decimal` |\\n| `t.Boolean(name)` | BOOLEAN | `bool` |\\n| `t.Timestamp(name)` | TIMESTAMP | `time.Time` |\\n| `t.JSONB(name)` | JSONB | `json.RawMessage` |\\n| `t.Date(name)` | DATE | `time.Time` |\\n| `t.Time(name)` | TIME | `time.Time` |\\n| `t.Binary(name)` | BYTEA | `[]byte` |\\n| `t.Timestamps()` | — | Adds `created_at` + `updated_at` with NOW() defaults |\\n\\n## Column modifiers\\n\\nChain these on any column:\\n\\n```go\\nt.String(\\\"email\\\").NotNull().Unique()\\nt.UUID(\\\"id\\\").PrimaryKey().Default(\\\"uuid_generate_v7()\\\")\\nt.UUID(\\\"team_id\\\").NotNull().ForeignKey(\\\"teams\\\", \\\"id\\\")\\nt.Text(\\\"notes\\\").Nullable()\\n```\\n\\n| Modifier | Description |\\n|----------|-------------|\\n| `.PrimaryKey()` | Mark as primary key |\\n| `.NotNull()` | NOT NULL constraint |\\n| `.Nullable()` | Allow NULL (default for most columns) |\\n| `.Unique()` | UNIQUE constraint |\\n| `.Default(value)` | Set default value |\\n| `.ForeignKey(table, column)` | Add foreign key reference |\\n| `.Public()` | Mark as visible to anyone (ownership system) |\\n| `.OwnerSees()` | Mark as visible only to the row's owner |\\n| `.IsOwner()` | Mark as the ownership column for the table |\\n\\n## Ownership \\u0026 visibility\\n\\nDeclare field visibility tiers and row ownership directly in your migration. Pickle generates `PublicResponse` and `OwnerResponse` structs, a `Serialize` function, and a `WhereOwnedBy` query scope.\\n\\n```go\\nm.CreateTable(\\\"posts\\\", func(t *Table) {\\n    t.UUID(\\\"id\\\").PrimaryKey().Default(\\\"uuid_generate_v7()\\\").Public()\\n    t.UUID(\\\"user_id\\\").NotNull().ForeignKey(\\\"users\\\", \\\"id\\\").IsOwner()\\n    t.String(\\\"title\\\").NotNull().Public()\\n    t.Text(\\\"body\\\").NotNull().OwnerSees()\\n    t.String(\\\"draft_notes\\\").Nullable().OwnerSees()\\n    t.Timestamps()\\n})\\n```\\n\\n| Modifier | Effect |\\n|----------|--------|\\n| `.Public()` | Field appears in both `PostPublicResponse` and `PostOwnerResponse` |\\n| `.OwnerSees()` | Field appears only in `PostOwnerResponse` |\\n| `.IsOwner()` | Column used to determine ownership — generates `WhereOwnedBy` scope |\\n\\nPickle generates:\\n\\n- `PostPublicResponse` struct — only `.Public()` fields\\n- `PostOwnerResponse` struct — `.Public()` + `.OwnerSees()` fields\\n- `SerializePost(record, ownerID)` — returns the appropriate response based on ownership match\\n- `SerializePosts(records, ownerID)` — slice variant\\n- `WhereOwnedBy(ownerID)` — query scope filtering by the owner column\\n\\nOnly one column per table may be marked `.IsOwner()`. Tables without any ownership modifiers generate no response structs.\\n\\n## Migration operations\\n\\nAvailable in `Up()` and `Down()`:\\n\\n| Method | Description |\\n|--------|-------------|\\n| `m.CreateTable(name, fn)` | Create a table |\\n| `m.DropTableIfExists(name)` | Drop a table |\\n| `m.AddColumn(table, name, fn)` | Add a column to an existing table |\\n| `m.DropColumn(table, name)` | Drop a column |\\n| `m.RenameColumn(table, old, new)` | Rename a column |\\n| `m.AddIndex(table, columns...)` | Add an index |\\n| `m.AddUniqueIndex(table, columns...)` | Add a unique index |\\n| `m.RenameTable(old, new)` | Rename a table |\\n\\n## Running migrations\\n\\n```bash\\npickle migrate           # Run pending migrations\\npickle migrate:rollback  # Rollback last batch\\npickle migrate:fresh     # Drop all tables and re-run\\npickle migrate:status    # Show migration status\\n```\\n\\n## Transactional migrations\\n\\nMigrations run inside a transaction by default. Override for operations that can't be transactional:\\n\\n```go\\nfunc (m *AddSearchIndex_2026_03_01_120000) Transactional() bool { return false }\\n```\\n\\n## Model generation\\n\\nFrom the migration above, Pickle generates:\\n\\n```go\\n// models/user.go (GENERATED — DO NOT EDIT)\\ntype User struct {\\n    ID        uuid.UUID `json:\\\"id\\\" db:\\\"id\\\"`\\n    Name      string    `json:\\\"name\\\" db:\\\"name\\\"`\\n    Email     string    `json:\\\"email\\\" db:\\\"email\\\"`\\n    Password  string    `json:\\\"password\\\" db:\\\"password\\\"`\\n    Bio       *string   `json:\\\"bio,omitempty\\\" db:\\\"bio\\\"`\\n    CreatedAt time.Time `json:\\\"created_at\\\" db:\\\"created_at\\\"`\\n    UpdatedAt time.Time `json:\\\"updated_at\\\" db:\\\"updated_at\\\"`\\n}\\n```\\n\\nNullable columns become pointer types (`*string`, `*time.Time`). The `json` and `db` struct tags are generated automatically.\\n\"\n  },\n  {\n    \"name\": \"QueryBuilder\",\n    \"description\": \"The generic typed query builder for all models. Pickle generates a model-specific wrapper (e.g. `UserQuery`) with typed `Where*` scope methods, but the underlying CRUD and query building is handled by `QueryBuilder[T]`.\",\n    \"content\": \"# QueryBuilder\\n\\nThe generic typed query builder for all models. Pickle generates a model-specific wrapper (e.g. `UserQuery`) with typed `Where*` scope methods, but the underlying CRUD and query building is handled by `QueryBuilder[T]`.\\n\\n## Generated query types\\n\\nFor each table, Pickle generates:\\n\\n```go\\n// models/user_query.go (GENERATED)\\ntype UserQuery struct {\\n    *QueryBuilder[User]\\n}\\n\\nfunc QueryUser() *UserQuery { ... }\\n\\n// Type-safe scopes\\nfunc (q *UserQuery) WhereID(id uuid.UUID) *UserQuery { ... }\\nfunc (q *UserQuery) WhereEmail(email string) *UserQuery { ... }\\nfunc (q *UserQuery) WhereEmailLike(pattern string) *UserQuery { ... }\\nfunc (q *UserQuery) WithPosts() *UserQuery { ... }\\n```\\n\\n## Querying\\n\\n```go\\n// Find one record\\nuser, err := models.QueryUser().WhereID(id).First()\\n\\n// Find all matching\\nusers, err := models.QueryUser().WhereRole(\\\"admin\\\").All()\\n\\n// Count\\nn, err := models.QueryUser().WhereRole(\\\"admin\\\").Count()\\n\\n// Ordering and pagination\\nusers, err := models.QueryUser().\\n    OrderBy(\\\"created_at\\\", \\\"DESC\\\").\\n    Limit(20).\\n    Offset(40).\\n    All()\\n\\n// Eager load relationships\\nuser, err := models.QueryUser().\\n    WhereEmail(email).\\n    WithPosts().\\n    First()\\n```\\n\\n## CRUD\\n\\n```go\\n// Create — inserts and scans back DB-generated values (UUID, timestamps)\\nuser := \\u0026models.User{Name: \\\"Alice\\\", Email: \\\"alice@example.com\\\"}\\nerr := models.QueryUser().Create(user)\\n// user.ID and user.CreatedAt are now populated\\n\\n// Update — updates all fields, uses ID for WHERE by default\\nuser.Name = \\\"Bob\\\"\\nerr := models.QueryUser().Update(user)\\n\\n// Update with explicit conditions\\nerr := models.QueryUser().WhereID(id).Update(user)\\n\\n// Delete\\nerr := models.QueryUser().WhereID(id).Delete(\\u0026models.User{})\\n```\\n\\n## Generic methods (from QueryBuilder[T])\\n\\nThese are inherited by all model query types:\\n\\n| Method | Returns | Description |\\n|--------|---------|-------------|\\n| `Where(column, value)` | `*QueryBuilder[T]` | Add `column = value` condition |\\n| `WhereOp(column, op, value)` | `*QueryBuilder[T]` | Add `column op value` condition |\\n| `WhereIn(column, values)` | `*QueryBuilder[T]` | Add `column IN (...)` condition |\\n| `WhereNotIn(column, values)` | `*QueryBuilder[T]` | Add `column NOT IN (...)` condition |\\n| `OrderBy(column, direction)` | `*QueryBuilder[T]` | Add ORDER BY clause |\\n| `Limit(n)` | `*QueryBuilder[T]` | Set LIMIT |\\n| `Offset(n)` | `*QueryBuilder[T]` | Set OFFSET |\\n| `EagerLoad(relation)` | `*QueryBuilder[T]` | Mark relationship for eager loading |\\n| `First()` | `(*T, error)` | Return first matching record |\\n| `All()` | `([]T, error)` | Return all matching records |\\n| `Count()` | `(int64, error)` | Count matching records |\\n| `Create(record)` | `error` | INSERT with RETURNING (populates DB defaults) |\\n| `Update(record)` | `error` | UPDATE by conditions or by ID |\\n| `Delete(record)` | `error` | DELETE matching records |\\n\\n## Generated scope methods\\n\\nFor each column, Pickle generates type-safe scopes:\\n\\n**All types:**\\n- `Where{Column}(val)` — exact match\\n- `Where{Column}Not(val)` — not equal\\n- `Where{Column}In(vals)` — IN list\\n- `Where{Column}NotIn(vals)` — NOT IN list\\n\\n**String columns:**\\n- `Where{Column}Like(pattern)` — SQL LIKE\\n- `Where{Column}NotLike(pattern)` — SQL NOT LIKE\\n\\n**Numeric columns (Integer, BigInteger, Decimal):**\\n- `Where{Column}GT(val)`, `GTE`, `LT`, `LTE` — comparisons\\n\\n**Timestamp columns:**\\n- `Where{Column}Before(time)`, `After(time)`, `Between(start, end)`\\n\\n**Foreign key columns:**\\n- `With{Relation}()` — eager load the related model\\n\\n## Database connection\\n\\nThe query builder uses the package-level `models.DB` variable (a `*sql.DB`). This is set during app initialization by the generated commands package. All queries use parameterized `$1, $2, ...` placeholders — no string interpolation, no SQL injection.\\n\"\n  },\n  {\n    \"name\": \"Requests\",\n    \"description\": \"Request classes define incoming JSON payloads with validation rules. Pickle generates `Bind` functions that deserialize and validate in one step.\",\n    \"content\": \"# Requests\\n\\nRequest classes define incoming JSON payloads with validation rules. Pickle generates `Bind` functions that deserialize and validate in one step.\\n\\n## Writing a request\\n\\n```go\\n// app/http/requests/create_user.go\\npackage requests\\n\\ntype CreateUserRequest struct {\\n    Name     string `json:\\\"name\\\" validate:\\\"required,min=2,max=100\\\"`\\n    Email    string `json:\\\"email\\\" validate:\\\"required,email\\\"`\\n    Password string `json:\\\"password\\\" validate:\\\"required,min=8\\\"`\\n    Role     string `json:\\\"role\\\" validate:\\\"omitempty,oneof=user admin\\\"`\\n}\\n```\\n\\n## Validation tags\\n\\nPickle uses `github.com/go-playground/validator/v10` for struct validation. Common tags:\\n\\n| Tag | Description |\\n|-----|-------------|\\n| `required` | Field must be present and non-zero |\\n| `email` | Must be valid email format |\\n| `min=N` | Minimum length (string) or value (number) |\\n| `max=N` | Maximum length or value |\\n| `oneof=a b c` | Must be one of the listed values |\\n| `uuid` | Must be valid UUID |\\n| `url` | Must be valid URL |\\n| `omitempty` | Skip validation if field is zero value |\\n\\nCombine with commas: `validate:\\\"required,email\\\"`, `validate:\\\"required,min=1,max=100\\\"`.\\n\\n## Generated binding\\n\\nPickle generates a `Bind` function for each request struct:\\n\\n```go\\n// requests/bindings_gen.go (GENERATED)\\nfunc BindCreateUserRequest(r *http.Request) (CreateUserRequest, *BindingError)\\n```\\n\\n## Using in controllers\\n\\n```go\\nfunc (c UserController) Store(ctx *pickle.Context) pickle.Response {\\n    req, bindErr := requests.BindCreateUserRequest(ctx.Request())\\n    if bindErr != nil {\\n        return ctx.JSON(bindErr.Status, bindErr)\\n    }\\n\\n    // req is a validated CreateUserRequest — use it safely\\n    user := \\u0026models.User{\\n        Name:  req.Name,\\n        Email: req.Email,\\n    }\\n    // ...\\n}\\n```\\n\\n## BindingError\\n\\nWhen binding fails, the `*BindingError` contains:\\n\\n```go\\ntype BindingError struct {\\n    Status  int               `json:\\\"status\\\"`\\n    Message string            `json:\\\"message\\\"`\\n    Errors  map[string]string `json:\\\"errors,omitempty\\\"`\\n}\\n```\\n\\n- JSON parse errors → `400` with a message\\n- Validation errors → `422` with a map of field → error message\\n\\nExample error response:\\n\\n```json\\n{\\n    \\\"status\\\": 422,\\n    \\\"message\\\": \\\"validation failed\\\",\\n    \\\"errors\\\": {\\n        \\\"email\\\": \\\"must be a valid email address\\\",\\n        \\\"password\\\": \\\"must be at least 8 characters\\\"\\n    }\\n}\\n```\\n\\n## Mass assignment protection\\n\\nOnly fields defined in the request struct are deserialized. POSTing `{\\\"role\\\": \\\"admin\\\"}` does nothing if the request struct doesn't have a `Role` field. This is structural protection — there's no way to bypass it.\\n\\n## Request location\\n\\nRequest files live in `app/http/requests/`. One file per request, named after the operation: `create_user.go`, `update_user.go`, `login.go`.\\n\"\n  },\n  {\n    \"name\": \"Response\",\n    \"description\": \"The return type from every controller and middleware. A simple value type with a status code, body, and headers.\",\n    \"content\": \"# Response\\n\\nThe return type from every controller and middleware. A simple value type with a status code, body, and headers.\\n\\nYou almost never construct `Response` directly — use `ctx.JSON()`, `ctx.Error()`, etc. But you can add headers to any response using the `.Header()` method.\\n\\n## Adding headers\\n\\n`.Header()` returns a copy with the header set, so you can chain it:\\n\\n```go\\nreturn ctx.JSON(200, data).\\n    Header(\\\"X-Request-ID\\\", requestID).\\n    Header(\\\"Cache-Control\\\", \\\"no-cache\\\")\\n```\\n\\n## Structure\\n\\n```go\\ntype Response struct {\\n    StatusCode int\\n    Body       any\\n    Headers    map[string]string\\n}\\n```\\n\\n- `Body` is JSON-marshaled when written. If `nil`, no body is written.\\n- `StatusCode` defaults to 200 if body is present, 204 if nil.\\n- `Content-Type` defaults to `application/json` if not explicitly set.\\n\\n## Writing\\n\\nThe router calls `resp.Write(w)` automatically — you never call it yourself. It marshals the body to JSON, sets headers, and writes the status code.\\n\\n## Method reference\\n\\n| Method | Returns | Description |\\n|--------|---------|-------------|\\n| `Header(key, value)` | `Response` | Returns a copy with the header added |\\n| `Write(w)` | — | Serializes to an `http.ResponseWriter` (called by router) |\\n\"\n  },\n  {\n    \"name\": \"Router\",\n    \"description\": \"Defines your API routes in a single file. Registers handlers onto Go 1.22+ `net/http.ServeMux` with path parameters, middleware groups, and resource routes.\",\n    \"content\": \"# Router\\n\\nDefines your API routes in a single file. Registers handlers onto Go 1.22+ `net/http.ServeMux` with path parameters, middleware groups, and resource routes.\\n\\nAll routes are defined in `routes/web.go`. The Router is both a route collector and a runtime registrar — no code generation needed for routing.\\n\\n## Defining routes\\n\\n```go\\n// routes/web.go\\npackage routes\\n\\nimport (\\n    pickle \\\"myapp/app/http\\\"\\n    \\\"myapp/app/http/controllers\\\"\\n    \\\"myapp/app/http/middleware\\\"\\n)\\n\\nvar API = pickle.Routes(func(r *pickle.Router) {\\n    r.Group(\\\"/api\\\", func(r *pickle.Router) {\\n        r.Post(\\\"/login\\\", controllers.AuthController{}.Login)\\n\\n        r.Group(\\\"/users\\\", func(r *pickle.Router) {\\n            r.Get(\\\"/\\\", controllers.UserController{}.Index)\\n            r.Get(\\\"/:id\\\", controllers.UserController{}.Show)\\n            r.Post(\\\"/\\\", controllers.UserController{}.Store)\\n        }, middleware.Auth)\\n    })\\n})\\n```\\n\\n## HTTP methods\\n\\n```go\\nr.Get(path, handler, ...middleware)\\nr.Post(path, handler, ...middleware)\\nr.Put(path, handler, ...middleware)\\nr.Patch(path, handler, ...middleware)\\nr.Delete(path, handler, ...middleware)\\n```\\n\\nEach method takes a path, a handler `func(*Context) Response`, and optional per-route middleware.\\n\\n## Path parameters\\n\\nUse `:name` syntax. Parameters are read via `ctx.Param(\\\"name\\\")`:\\n\\n```go\\nr.Get(\\\"/users/:id\\\", controllers.UserController{}.Show)\\n// ctx.Param(\\\"id\\\") → \\\"abc-123\\\"\\n```\\n\\nInternally, `:id` is converted to Go 1.22+ `{id}` patterns.\\n\\n## Groups\\n\\nGroups share a path prefix and middleware. The body function comes second; middleware follows as variadic arguments:\\n\\n```go\\nr.Group(\\\"/admin\\\", func(r *pickle.Router) {\\n    r.Get(\\\"/dashboard\\\", controllers.AdminController{}.Dashboard)\\n    r.Get(\\\"/users\\\", controllers.AdminController{}.Users)\\n}, middleware.Auth, middleware.RequireRole(\\\"admin\\\"))\\n```\\n\\nGroups nest. Middleware cascades from outer to inner groups.\\n\\n## Resource routes\\n\\n`r.Resource()` registers all five CRUD routes for a controller that implements `ResourceController`:\\n\\n```go\\nr.Resource(\\\"/posts\\\", controllers.PostController{})\\n```\\n\\nRegisters:\\n| Method | Path | Handler |\\n|--------|------|---------|\\n| GET | /posts | Index |\\n| GET | /posts/:id | Show |\\n| POST | /posts | Store |\\n| PUT | /posts/:id | Update |\\n| DELETE | /posts/:id | Destroy |\\n\\nThe controller must implement the `ResourceController` interface:\\n\\n```go\\ntype ResourceController interface {\\n    Index(*Context) Response\\n    Show(*Context) Response\\n    Store(*Context) Response\\n    Update(*Context) Response\\n    Destroy(*Context) Response\\n}\\n```\\n\\n## Registering routes\\n\\nIn `cmd/server/main.go`, routes are wired up via the generated `commands` package. If you need manual control:\\n\\n```go\\nmux := http.NewServeMux()\\nroutes.API.RegisterRoutes(mux)\\nhttp.ListenAndServe(\\\":8080\\\", mux)\\n```\\n\\nOr use the convenience method:\\n\\n```go\\nroutes.API.ListenAndServe(\\\":8080\\\")\\n```\\n\\n## Method reference\\n\\n| Method | Description |\\n|--------|-------------|\\n| `Routes(fn)` | Create a new Router via a configuration function |\\n| `Get/Post/Put/Patch/Delete(path, handler, ...mw)` | Register a route |\\n| `Group(prefix, fn, ...mw)` | Create a sub-router with shared prefix and middleware |\\n| `Resource(prefix, controller, ...mw)` | Register CRUD routes for a ResourceController |\\n| `AllRoutes()` | Return flattened list of all routes with resolved prefixes/middleware |\\n| `RegisterRoutes(mux)` | Wire all routes onto an `*http.ServeMux` |\\n| `ListenAndServe(addr)` | Convenience: create mux, register routes, start server |\\n\"\n  },\n  {\n    \"name\": \"Tickle\",\n    \"description\": \"\\u003e The thing that tickles the pickle.\",\n    \"content\": \"# Tickle\\n\\n\\u003e The thing that tickles the pickle.\\n\\n## What Is Tickle?\\n\\nTickle is Pickle's preprocessor. It takes the idiomatic Go you write — controllers, migrations, requests, routes — and transforms it into code that compiles alongside Pickle's generated output.\\n\\nThe problem: you write `Query[User]()` in a controller, but `Query[T]` doesn't exist until Pickle generates it. Your linter screams. Your IDE is useless. You can't run `go vet` on code that references types that don't exist yet.\\n\\nTickle bridges that gap. It processes your source files, resolves references to generated types, adds the correct imports, and produces compilable Go. You develop against real, lintable code. Tickle makes it build.\\n\\n## The Pipeline\\n\\n```\\nYou write idiomatic Go\\n        ↓\\n   tickle runs\\n        ↓\\nPickle-compatible source (compiles with generated output)\\n        ↓\\n   pickle generates\\n        ↓\\nFramework code (models, queries, routes, bindings, pickle.go)\\n        ↓\\n   go build\\n        ↓\\nStatic binary\\n```\\n\\n## Why?\\n\\nWithout Tickle, you have two bad options:\\n\\n1. **Write against generated types** — your code doesn't lint or compile until after `pickle generate` runs. No IDE support, no `go vet`, no feedback loop while writing.\\n2. **Maintain stub types** — manually keep dummy type definitions in sync with what Pickle generates. Tedious, error-prone, defeats the purpose.\\n\\nTickle gives you a third option: write normal Go that references `Query[T]`, `Context`, `Response`, etc. as if they exist. Tickle knows what Pickle will generate and transforms your code to work with it.\\n\\n## What Tickle Does\\n\\n- Resolves references to generated types (`Query[T]`, `Context`, `Response`, `Router`, middleware types)\\n- Adds correct import paths pointing to the `generated/` package\\n- Transforms controller method signatures to match the generated binding interface\\n- Validates that migration DSL calls use known methods and column types\\n- Ensures `routes.go` references valid controller methods\\n\\n## What Tickle Does NOT Do\\n\\n- Generate models, queries, or route wiring — that's Pickle's job\\n- Modify your source files in place — Tickle outputs to a staging directory\\n- Run at runtime — Tickle is a build step, like Pickle itself\\n\\n## Usage\\n\\n```bash\\n# Tickle only (rarely needed standalone)\\npickle tickle\\n\\n# Generate always tickles first — tickle is a prerequisite, not optional\\npickle generate   # tickle → generate\\n\\n# Watch mode runs the full pipeline\\npickle --watch    # tickle → generate → go build → restart\\n```\\n\\nTickle always runs before generation. There is no way to generate without tickling first — the generator expects tickled source as input. This is a linear pipeline, not a recursive compiler.\\n\\n## Flow in Watch Mode\\n\\n```\\nFile saved\\n  → Tickle processes changed file\\n    → Pickle regenerates affected output\\n      → go build\\n        → Binary restarted\\n```\\n\\nOne save, full pipeline, no manual steps.\\n\"\n  },\n  {\n    \"name\": \"Views\",\n    \"description\": \"Views let you define database views in your migration files. Pickle generates read-only model structs and typed query scopes from them — same as tables, minus the write operations.\",\n    \"content\": \"# Views\\n\\nViews let you define database views in your migration files. Pickle generates read-only model structs and typed query scopes from them — same as tables, minus the write operations.\\n\\n## When to Use Views\\n\\n- Computed columns (aggregations, window functions)\\n- Joins you query frequently\\n- Denormalized read models\\n- Anything where `SELECT` is all you need\\n\\n## CreateView / DropView\\n\\n```go\\nfunc (m *MyMigration) Up() {\\n    m.CreateView(\\\"customer_transfer_rankings\\\", func(v *View) {\\n        v.From(\\\"transfers\\\", \\\"t\\\")\\n        v.Join(\\\"customers\\\", \\\"c\\\", \\\"c.id = t.customer_id\\\")\\n        v.Column(\\\"t.id\\\")\\n        v.Column(\\\"t.customer_id\\\")\\n        v.Column(\\\"c.name\\\", \\\"customer_name\\\")\\n        v.Column(\\\"t.created_at\\\")\\n        v.GroupBy(\\\"t.customer_id\\\", \\\"c.name\\\", \\\"t.id\\\", \\\"t.created_at\\\")\\n        v.SelectRaw(\\\"rank\\\", \\\"ROW_NUMBER() OVER (PARTITION BY t.customer_id ORDER BY t.created_at DESC)\\\").BigInteger()\\n        v.SelectRaw(\\\"total_amount\\\", \\\"SUM(t.amount) OVER (PARTITION BY t.customer_id)\\\").Decimal(18, 2)\\n    })\\n}\\n\\nfunc (m *MyMigration) Down() {\\n    m.DropView(\\\"customer_transfer_rankings\\\")\\n}\\n```\\n\\n## DSL Reference\\n\\n### Sources\\n\\n| Method | Description |\\n|--------|-------------|\\n| `v.From(table, alias)` | Primary source table |\\n| `v.Join(table, alias, on)` | INNER JOIN |\\n| `v.LeftJoin(table, alias, on)` | LEFT JOIN |\\n\\nAll sources require aliases. Column references use `\\\"alias.column\\\"` format to avoid ambiguity.\\n\\n### Columns\\n\\n| Method | Description |\\n|--------|-------------|\\n| `v.Column(\\\"t.id\\\")` | Reference a source column — type is resolved from the source table |\\n| `v.Column(\\\"c.name\\\", \\\"customer_name\\\")` | Same, with an output alias |\\n| `v.SelectRaw(\\\"name\\\", \\\"SQL expr\\\")` | Computed column — must declare type explicitly |\\n| `v.GroupBy(\\\"col1\\\", \\\"col2\\\")` | GROUP BY clause |\\n\\n### Type Builders (for SelectRaw)\\n\\nChain a type method after `SelectRaw` to declare the Go type:\\n\\n```go\\nv.SelectRaw(\\\"rank\\\", \\\"ROW_NUMBER() OVER (...)\\\").BigInteger()\\nv.SelectRaw(\\\"total\\\", \\\"SUM(amount)\\\").Decimal(18, 2)\\nv.SelectRaw(\\\"label\\\", \\\"CONCAT(first, ' ', last)\\\").StringType()\\nv.SelectRaw(\\\"is_active\\\", \\\"CASE WHEN ...\\\").BooleanType()\\nv.SelectRaw(\\\"last_seen\\\", \\\"MAX(created_at)\\\").TimestampType()\\nv.SelectRaw(\\\"user_id\\\", \\\"t.user_id\\\").UUIDType()\\nv.SelectRaw(\\\"data\\\", \\\"jsonb_agg(...)\\\").JSONBType()\\nv.SelectRaw(\\\"note\\\", \\\"string_agg(...)\\\").TextType()\\nv.SelectRaw(\\\"count\\\", \\\"COUNT(*)\\\").IntegerType()\\n```\\n\\n## Type Resolution\\n\\n- **Plain columns** (`v.Column(\\\"t.id\\\")`) — type is resolved from the source table's schema at generation time. If the source table defines `id` as UUID, the view column is UUID.\\n- **SelectRaw columns** — type must be declared explicitly via builder methods. Pickle can't infer types from SQL expressions.\\n\\n## Generated Code\\n\\nGiven the view above, Pickle generates:\\n\\n**Model struct** (`models/customerTransferRanking.go`):\\n```go\\ntype CustomerTransferRanking struct {\\n    ID             uuid.UUID       `json:\\\"id\\\" db:\\\"id\\\"`\\n    CustomerID     uuid.UUID       `json:\\\"customer_id\\\" db:\\\"customer_id\\\"`\\n    CustomerName   string          `json:\\\"customer_name\\\" db:\\\"customer_name\\\"`\\n    CreatedAt      time.Time       `json:\\\"created_at\\\" db:\\\"created_at\\\"`\\n    Rank           int64           `json:\\\"rank\\\" db:\\\"rank\\\"`\\n    TotalAmount    decimal.Decimal `json:\\\"total_amount\\\" db:\\\"total_amount\\\"`\\n}\\n```\\n\\n**Read-only query type** (`models/customerTransferRanking_query.go`):\\n```go\\ntype CustomerTransferRankingQuery struct {\\n    *QueryBuilder[CustomerTransferRanking]\\n}\\n\\nfunc QueryCustomerTransferRanking() *CustomerTransferRankingQuery { ... }\\n\\n// Where methods for each column\\nfunc (q *CustomerTransferRankingQuery) WhereCustomerID(val uuid.UUID) *CustomerTransferRankingQuery { ... }\\nfunc (q *CustomerTransferRankingQuery) WhereRank(val int64) *CustomerTransferRankingQuery { ... }\\n// etc.\\n```\\n\\nViews generate **read-only** query types. There are no `Create`, `Update`, or `Delete` methods — those are only available on table models.\\n\\n## Usage\\n\\n```go\\n// Top 10 customers by transfer count\\nrankings, err := models.QueryCustomerTransferRanking().\\n    WhereRankLTE(10).\\n    All()\\n\\n// Stats for a specific user\\nstats, err := models.QueryUserPostStat().\\n    WhereID(userID).\\n    First()\\n```\\n\"\n  }\n]"
