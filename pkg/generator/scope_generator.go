package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"strings"

	"github.com/shortontech/pickle/pkg/schema"
	"github.com/shortontech/pickle/pkg/tickle"
)

// GenerateQueryScopes produces a Go source file with typed Where*/With* methods
// for a given table, using scope templates parsed from the cooked scopes file.
func GenerateQueryScopes(table *schema.Table, blocks []tickle.ScopeBlock, packageName string) ([]byte, error) {
	columns := tickle.ColumnsFromTable(table)
	structName := tableToStructName(table.Name)
	scopeBody := tickle.GenerateScopes(blocks, columns, structName)

	// Collect imports needed by the generated scopes
	imports := collectScopeImports(table, blocks)

	var b bytes.Buffer
	b.WriteString("// Code generated by Pickle. DO NOT EDIT.\n")
	b.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	if len(imports) > 0 {
		b.WriteString("import (\n")
		for _, imp := range imports {
			b.WriteString(fmt.Sprintf("\t%q\n", imp))
		}
		b.WriteString(")\n\n")
	}

	// Generate the model-specific query wrapper type
	queryType := structName + "Query"
	b.WriteString(fmt.Sprintf("// %s provides typed query methods for %s.\n", queryType, structName))
	b.WriteString(fmt.Sprintf("type %s struct {\n\t*QueryBuilder[%s]\n}\n\n", queryType, structName))

	// Generate a typed Query constructor
	b.WriteString(fmt.Sprintf("// Query%s starts a new query for %s.\n", structName, structName))
	b.WriteString(fmt.Sprintf("func Query%s() *%s {\n", structName, queryType))
	b.WriteString(fmt.Sprintf("\treturn &%s{QueryBuilder: Query[%s](%q)}\n", queryType, structName, table.Name))
	b.WriteString("}\n\n")

	// Generate eager loading methods from foreign keys
	for _, col := range table.Columns {
		if col.ForeignKeyTable != "" {
			relName := tableToStructName(col.ForeignKeyTable)
			b.WriteString(fmt.Sprintf("func (q *%s) With%s() *%s {\n", queryType, relName, queryType))
			b.WriteString(fmt.Sprintf("\tq.EagerLoad(%q)\n", col.ForeignKeyTable))
			b.WriteString(fmt.Sprintf("\treturn q\n"))
			b.WriteString("}\n\n")
		}
	}

	// Generate ownership scope if table has an owner column
	for _, col := range table.Columns {
		if col.IsOwnerColumn {
			goType := columnGoType(col)
			paramName := "ownerID"
			b.WriteString(fmt.Sprintf("// WhereOwnedBy filters records by the ownership column.\n"))
			b.WriteString(fmt.Sprintf("func (q *%s) WhereOwnedBy(%s %s) *%s {\n", queryType, paramName, goType, queryType))
			b.WriteString(fmt.Sprintf("\tq.Where(%q, %s)\n", col.Name, paramName))
			b.WriteString(fmt.Sprintf("\treturn q\n"))
			b.WriteString("}\n\n")
			break
		}
	}

	// Generate table-level scopes (FetchResource / FetchResources)
	tableScopeBody := tickle.GenerateTableScopes(blocks, structName, HasOwnership(table))
	b.WriteString(tableScopeBody)

	b.WriteString(scopeBody)

	formatted, err := format.Source(b.Bytes())
	if err != nil {
		return b.Bytes(), fmt.Errorf("go format: %w\n%s", err, b.String())
	}

	return formatted, nil
}

// GenerateViewQueryScopes produces a Go source file with typed Where* methods
// for a view. The query wrapper is read-only â€” no Create/Update/Delete.
func GenerateViewQueryScopes(view *schema.View, blocks []tickle.ScopeBlock, packageName string) ([]byte, error) {
	// Build columns from view columns
	var columns []tickle.ColumnDef
	for _, vc := range view.Columns {
		col := &vc.Column
		col.Name = vc.OutputName()
		columns = append(columns, tickle.ColumnDef{
			PascalName: snakeToPascal(col.Name),
			SnakeName:  col.Name,
			GoType:     columnGoType(col),
			Scope:      tickle.ScopeForType(col.Type),
		})
	}

	structName := tableToStructName(view.Name)
	scopeBody := tickle.GenerateScopes(blocks, columns, structName)

	imports := collectViewScopeImports(view, blocks)

	var b bytes.Buffer
	b.WriteString("// Code generated by Pickle. DO NOT EDIT.\n")
	b.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	if len(imports) > 0 {
		b.WriteString("import (\n")
		for _, imp := range imports {
			b.WriteString(fmt.Sprintf("\t%q\n", imp))
		}
		b.WriteString(")\n\n")
	}

	queryType := structName + "Query"
	b.WriteString(fmt.Sprintf("// %s provides read-only typed query methods for the %s view.\n", queryType, view.Name))
	b.WriteString(fmt.Sprintf("type %s struct {\n\t*QueryBuilder[%s]\n}\n\n", queryType, structName))

	b.WriteString(fmt.Sprintf("// Query%s starts a new read-only query for %s.\n", structName, structName))
	b.WriteString(fmt.Sprintf("func Query%s() *%s {\n", structName, queryType))
	b.WriteString(fmt.Sprintf("\treturn &%s{QueryBuilder: Query[%s](%q)}\n", queryType, structName, view.Name))
	b.WriteString("}\n\n")

	b.WriteString(scopeBody)

	formatted, err := format.Source(b.Bytes())
	if err != nil {
		return b.Bytes(), fmt.Errorf("go format: %w\n%s", err, b.String())
	}

	return formatted, nil
}

func collectViewScopeImports(view *schema.View, blocks []tickle.ScopeBlock) []string {
	imports := map[string]bool{}

	hasTimestamp := false
	hasUUID := false
	hasDecimal := false
	hasJSONB := false

	for _, vc := range view.Columns {
		switch vc.Type {
		case schema.Timestamp, schema.Date:
			hasTimestamp = true
		case schema.UUID:
			hasUUID = true
		case schema.Decimal:
			hasDecimal = true
		case schema.JSONB:
			hasJSONB = true
		}
	}

	for _, block := range blocks {
		if block.Scope == "timestamp" && hasTimestamp {
			imports["time"] = true
		}
	}

	if hasUUID {
		imports["github.com/google/uuid"] = true
	}
	if hasDecimal {
		imports["github.com/shopspring/decimal"] = true
	}
	if hasTimestamp {
		imports["time"] = true
	}
	if hasJSONB {
		imports["encoding/json"] = true
	}

	var sorted []string
	for imp := range imports {
		sorted = append(sorted, imp)
	}

	var std, ext []string
	for _, imp := range sorted {
		if strings.Contains(imp, ".") {
			ext = append(ext, imp)
		} else {
			std = append(std, imp)
		}
	}
	return append(std, ext...)
}

func collectScopeImports(table *schema.Table, blocks []tickle.ScopeBlock) []string {
	imports := map[string]bool{}

	// Check if any timestamp columns exist and timestamp scopes are used
	hasTimestamp := false
	hasUUID := false
	hasDecimal := false
	hasJSONB := false

	for _, col := range table.Columns {
		switch col.Type {
		case schema.Timestamp, schema.Date:
			hasTimestamp = true
		case schema.UUID:
			hasUUID = true
		case schema.Decimal:
			hasDecimal = true
		case schema.JSONB:
			hasJSONB = true
		}
	}

	// Check if blocks reference these types
	for _, block := range blocks {
		if block.Scope == "timestamp" && hasTimestamp {
			imports["time"] = true
		}
	}

	// Always need these if columns of these types exist (for Where methods)
	if hasUUID {
		imports["github.com/google/uuid"] = true
	}
	if hasDecimal {
		imports["github.com/shopspring/decimal"] = true
	}
	if hasTimestamp {
		imports["time"] = true
	}
	if hasJSONB {
		imports["encoding/json"] = true
	}

	var sorted []string
	for imp := range imports {
		sorted = append(sorted, imp)
	}

	// Stdlib first
	var std, ext []string
	for _, imp := range sorted {
		if strings.Contains(imp, ".") {
			ext = append(ext, imp)
		} else {
			std = append(std, imp)
		}
	}
	return append(std, ext...)
}
