// Code generated by Pickle. DO NOT EDIT.
package basiccrud

import (
	"net/http"
	"strings"
	"encoding/json"
)

// AuthInfo holds authentication state set by middleware.
type AuthInfo struct {
	UserID string
	Role   string
	Claims any
}

// Context wraps an HTTP request and response, providing helpers for controllers and middleware.
type Context struct {
	request  *http.Request
	response http.ResponseWriter
	params   map[string]string
	auth     *AuthInfo
}

// NewContext creates a Context from an HTTP request/response pair.
func NewContext(w http.ResponseWriter, r *http.Request) *Context {
	return &Context{
		request:  r,
		response: w,
		params:   make(map[string]string),
	}
}

// Request returns the underlying *http.Request.
func (c *Context) Request() *http.Request {
	return c.request
}

// ResponseWriter returns the underlying http.ResponseWriter.
func (c *Context) ResponseWriter() http.ResponseWriter {
	return c.response
}

// Param returns a URL path parameter by name (e.g. :id).
func (c *Context) Param(name string) string {
	return c.params[name]
}

// SetParam sets a URL path parameter. Used by the generated route handler.
func (c *Context) SetParam(name, value string) {
	c.params[name] = value
}

// Query returns a query string parameter by name.
func (c *Context) Query(name string) string {
	return c.request.URL.Query().Get(name)
}

// BearerToken extracts the token from the Authorization: Bearer header.
func (c *Context) BearerToken() string {
	h := c.request.Header.Get("Authorization")
	if !strings.HasPrefix(h, "Bearer ") {
		return ""
	}
	return h[7:]
}

// SetAuth stores authentication info (called by auth middleware).
func (c *Context) SetAuth(claims any) {
	switch v := claims.(type) {
	case *AuthInfo:
		c.auth = v
	default:
		c.auth = &AuthInfo{Claims: v}
	}
}

// Auth returns the authenticated user info, or nil if not authenticated.
func (c *Context) Auth() *AuthInfo {
	return c.auth
}

// JSON returns a JSON response with the given status code and data.
func (c *Context) JSON(status int, data any) Response {
	return Response{
		StatusCode: status,
		Body:       data,
		Headers:    map[string]string{"Content-Type": "application/json"},
	}
}

// NoContent returns a 204 No Content response.
func (c *Context) NoContent() Response {
	return Response{StatusCode: http.StatusNoContent}
}

// Error returns a 500 Internal Server Error response.
func (c *Context) Error(err error) Response {
	return Response{
		StatusCode: http.StatusInternalServerError,
		Body:       map[string]string{"error": err.Error()},
		Headers:    map[string]string{"Content-Type": "application/json"},
	}
}

// NotFound returns a 404 response with a message.
func (c *Context) NotFound(msg string) Response {
	return Response{
		StatusCode: http.StatusNotFound,
		Body:       map[string]string{"error": msg},
		Headers:    map[string]string{"Content-Type": "application/json"},
	}
}

// Unauthorized returns a 401 response with a message.
func (c *Context) Unauthorized(msg string) Response {
	return Response{
		StatusCode: http.StatusUnauthorized,
		Body:       map[string]string{"error": msg},
		Headers:    map[string]string{"Content-Type": "application/json"},
	}
}

// Forbidden returns a 403 response with a message.
func (c *Context) Forbidden(msg string) Response {
	return Response{
		StatusCode: http.StatusForbidden,
		Body:       map[string]string{"error": msg},
		Headers:    map[string]string{"Content-Type": "application/json"},
	}
}

// Controller is the base type embedded by all controllers.
// It exists so the generator can identify controller types.
type Controller struct{}

// RunMiddleware executes a middleware stack around a handler.
// Middleware functions are called in order, each wrapping the next.
func RunMiddleware(ctx *Context, middleware []MiddlewareFunc, handler func() Response) Response {
	if len(middleware) == 0 {
		return handler()
	}

	// Build the chain from the inside out.
	next := handler
	for i := len(middleware) - 1; i >= 0; i-- {
		mw := middleware[i]
		inner := next
		next = func() Response {
			return mw(ctx, inner)
		}
	}

	return next()
}

// Response represents an HTTP response to be written.
type Response struct {
	StatusCode int
	Body       any
	Headers    map[string]string
}

// Header returns a copy of the response with an additional header set.
func (r Response) Header(key, value string) Response {
	if r.Headers == nil {
		r.Headers = make(map[string]string)
	}
	r.Headers[key] = value
	return r
}

// Write serializes the response to an http.ResponseWriter.
func (r Response) Write(w http.ResponseWriter) {
	for k, v := range r.Headers {
		w.Header().Set(k, v)
	}

	if r.Body == nil {
		if r.StatusCode == 0 {
			r.StatusCode = http.StatusNoContent
		}
		w.WriteHeader(r.StatusCode)
		return
	}

	if r.StatusCode == 0 {
		r.StatusCode = http.StatusOK
	}

	data, err := json.Marshal(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(`{"error":"internal server error"}`))
		return
	}

	if w.Header().Get("Content-Type") == "" {
		w.Header().Set("Content-Type", "application/json")
	}
	w.WriteHeader(r.StatusCode)
	w.Write(data)
}

// MiddlewareFunc is the signature for middleware functions.
type MiddlewareFunc func(ctx *Context, next func() Response) Response

// Route describes a single registered route.
type Route struct {
	Method     string
	Path       string
	Handler    any
	Middleware []MiddlewareFunc
}

// Router collects route definitions. It is a descriptor, not a runtime router.
type Router struct {
	prefix     string
	middleware []MiddlewareFunc
	routes     []Route
	groups     []*Router
}

// Routes creates a new Router by invoking the given configuration function.
func Routes(fn func(r *Router)) *Router {
	r := &Router{}
	fn(r)
	return r
}

func (r *Router) addRoute(method, path string, handler any, mw []MiddlewareFunc) {
	r.routes = append(r.routes, Route{
		Method:     method,
		Path:       path,
		Handler:    handler,
		Middleware: mw,
	})
}

// Get registers a GET route.
func (r *Router) Get(path string, handler any, mw ...MiddlewareFunc) {
	r.addRoute("GET", path, handler, mw)
}

// Post registers a POST route.
func (r *Router) Post(path string, handler any, mw ...MiddlewareFunc) {
	r.addRoute("POST", path, handler, mw)
}

// Put registers a PUT route.
func (r *Router) Put(path string, handler any, mw ...MiddlewareFunc) {
	r.addRoute("PUT", path, handler, mw)
}

// Patch registers a PATCH route.
func (r *Router) Patch(path string, handler any, mw ...MiddlewareFunc) {
	r.addRoute("PATCH", path, handler, mw)
}

// Delete registers a DELETE route.
func (r *Router) Delete(path string, handler any, mw ...MiddlewareFunc) {
	r.addRoute("DELETE", path, handler, mw)
}

// Group creates a sub-router with a shared prefix and optional middleware.
// The last func(*Router) argument is the group body; all other arguments
// before it are treated as MiddlewareFunc.
func (r *Router) Group(prefix string, args ...any) {
	g := &Router{prefix: prefix}

	for _, arg := range args {
		switch v := arg.(type) {
		case MiddlewareFunc:
			g.middleware = append(g.middleware, v)
		case func(r *Router):
			v(g)
		}
	}

	r.groups = append(r.groups, g)
}

// Resource registers standard CRUD routes for a controller.
// It looks for Index, Show, Store, Update, and Destroy methods via
// interface checks on the controller.
func (r *Router) Resource(prefix string, controller any, mw ...MiddlewareFunc) {
	type indexer interface{ Index(*Context) Response }
	type shower interface{ Show(*Context) Response }
	type destroyer interface{ Destroy(*Context) Response }

	if c, ok := controller.(indexer); ok {
		r.addRoute("GET", prefix, c.Index, mw)
	}
	if c, ok := controller.(shower); ok {
		r.addRoute("GET", prefix+"/:id", c.Show, mw)
	}
	// Store and Update use `any` handler since they take request structs â€”
	// the generator resolves the actual method signature.
	r.addRoute("POST", prefix, controller, mw)
	r.addRoute("PUT", prefix+"/:id", controller, mw)
	if c, ok := controller.(destroyer); ok {
		r.addRoute("DELETE", prefix+"/:id", c.Destroy, mw)
	}
}

// AllRoutes returns a flattened list of all routes with prefixes and
// middleware fully resolved.
func (r *Router) AllRoutes() []Route {
	return r.collectRoutes("", nil)
}

func (r *Router) collectRoutes(parentPrefix string, parentMW []MiddlewareFunc) []Route {
	fullPrefix := parentPrefix + r.prefix
	combinedMW := append(append([]MiddlewareFunc{}, parentMW...), r.middleware...)

	var routes []Route
	for _, route := range r.routes {
		resolved := Route{
			Method:     route.Method,
			Path:       fullPrefix + route.Path,
			Handler:    route.Handler,
			Middleware: append(append([]MiddlewareFunc{}, combinedMW...), route.Middleware...),
		}
		routes = append(routes, resolved)
	}

	for _, g := range r.groups {
		routes = append(routes, g.collectRoutes(fullPrefix, combinedMW)...)
	}

	return routes
}

