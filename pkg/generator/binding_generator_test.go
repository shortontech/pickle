package generator

import (
	"path/filepath"
	"strings"
	"testing"
)

func TestScanRequests(t *testing.T) {
	dir := filepath.Join("..", "..", "testdata", "basic-crud")
	requests, err := ScanRequests(dir)
	if err != nil {
		t.Fatalf("ScanRequests: %v", err)
	}

	if len(requests) != 4 {
		t.Fatalf("got %d requests, want 4", len(requests))
	}

	// Sorted alphabetically
	names := make([]string, len(requests))
	for i, r := range requests {
		names[i] = r.Name
	}
	want := []string{"CreatePostRequest", "CreateUserRequest", "UpdatePostRequest", "UserRequest"}
	// Filter to only *Request types we expect
	wantNames := map[string]bool{
		"CreatePostRequest":  true,
		"CreateUserRequest":  true,
		"UpdatePostRequest":  true,
		"UpdateUserRequest":  true,
	}
	for _, r := range requests {
		if !wantNames[r.Name] {
			t.Errorf("unexpected request: %s", r.Name)
		}
		delete(wantNames, r.Name)
	}
	for name := range wantNames {
		t.Errorf("missing request: %s", name)
	}
	_ = want

	// Check CreateUserRequest fields
	var createUser *RequestDef
	for i := range requests {
		if requests[i].Name == "CreateUserRequest" {
			createUser = &requests[i]
			break
		}
	}
	if createUser == nil {
		t.Fatal("CreateUserRequest not found")
	}

	if len(createUser.Fields) != 3 {
		t.Fatalf("CreateUserRequest has %d fields, want 3", len(createUser.Fields))
	}

	// Name field
	if f := createUser.Fields[0]; f.Name != "Name" || f.JSONTag != "name" || f.Validate != "required,min=1,max=255" {
		t.Errorf("field 0 = %+v", f)
	}

	// Email field
	if f := createUser.Fields[1]; f.Name != "Email" || f.JSONTag != "email" || f.Validate != "required,email,max=255" {
		t.Errorf("field 1 = %+v", f)
	}
}

func TestGenerateBindings(t *testing.T) {
	dir := filepath.Join("..", "..", "testdata", "basic-crud")
	requests, err := ScanRequests(dir)
	if err != nil {
		t.Fatalf("ScanRequests: %v", err)
	}

	out, err := GenerateBindings(requests, "basiccrud")
	if err != nil {
		t.Fatalf("GenerateBindings: %v", err)
	}

	output := string(out)

	// Should have generated header
	if !strings.Contains(output, "// Code generated by Pickle. DO NOT EDIT.") {
		t.Error("missing generated header")
	}

	// Should have bind functions for each request
	for _, name := range []string{"CreateUserRequest", "UpdateUserRequest", "CreatePostRequest", "UpdatePostRequest"} {
		if !strings.Contains(output, "func Bind"+name+"(r *http.Request)") {
			t.Errorf("missing Bind%s function", name)
		}
	}

	// Should have ValidationError and BindingError types
	if !strings.Contains(output, "type ValidationError struct") {
		t.Error("missing ValidationError type")
	}
	if !strings.Contains(output, "type BindingError struct") {
		t.Error("missing BindingError type")
	}

	// Should have formatValidationErrors helper
	if !strings.Contains(output, "func formatValidationErrors") {
		t.Error("missing formatValidationErrors helper")
	}

	// Should have human-readable error messages
	if !strings.Contains(output, `"is required"`) {
		t.Error("missing human-readable required message")
	}

	t.Logf("generated %d bytes", len(out))
}

func TestExtractTag(t *testing.T) {
	tests := []struct {
		raw, name, want string
	}{
		{"`json:\"name\" validate:\"required\"`", "json", "name"},
		{"`json:\"name\" validate:\"required\"`", "validate", "required"},
		{"`json:\"name,omitempty\"`", "json", "name"},
		{"`json:\"email\" validate:\"required,email,max=255\"`", "validate", "required,email,max=255"},
		{"`json:\"-\"`", "json", "-"},
		{"`db:\"id\"`", "json", ""},
	}

	for _, tt := range tests {
		got := extractTag(tt.raw, tt.name)
		if got != tt.want {
			t.Errorf("extractTag(%q, %q) = %q, want %q", tt.raw, tt.name, got, tt.want)
		}
	}
}
