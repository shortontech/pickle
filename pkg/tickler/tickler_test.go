package tickler

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestTickle(t *testing.T) {
	// Create temp dir with a fake cooked file
	dir := t.TempDir()
	src := `package cooked

import "database/sql"

var DB *sql.DB

func Query[T any]() *QueryBuilder[T] {
	return &QueryBuilder[T]{}
}
`
	if err := os.WriteFile(filepath.Join(dir, "query.go"), []byte(src), 0o644); err != nil {
		t.Fatal(err)
	}

	// Also write a test file that should be skipped
	if err := os.WriteFile(filepath.Join(dir, "query_test.go"), []byte("package cooked\n"), 0o644); err != nil {
		t.Fatal(err)
	}

	files, err := Tickle(dir, "generated")
	if err != nil {
		t.Fatalf("Tickle: %v", err)
	}

	if len(files) != 1 {
		t.Fatalf("expected 1 file, got %d", len(files))
	}

	out := files["query.go"]

	if !strings.Contains(out, "package generated") {
		t.Errorf("package not rewritten\n%s", out)
	}

	if strings.Contains(out, "package cooked") {
		t.Errorf("old package still present\n%s", out)
	}

	if !strings.Contains(out, "Code generated by Pickle. DO NOT EDIT.") {
		t.Errorf("missing generated header\n%s", out)
	}

	if !strings.Contains(out, "func Query[T any]()") {
		t.Errorf("function body missing\n%s", out)
	}
}

func TestTickleSkipsTestFiles(t *testing.T) {
	dir := t.TempDir()
	os.WriteFile(filepath.Join(dir, "query.go"), []byte("package cooked\n"), 0o644)
	os.WriteFile(filepath.Join(dir, "query_test.go"), []byte("package cooked\n"), 0o644)

	files, err := Tickle(dir, "generated")
	if err != nil {
		t.Fatal(err)
	}

	if _, ok := files["query_test.go"]; ok {
		t.Error("test file should be skipped")
	}
}

func TestTickleToFile(t *testing.T) {
	dir := t.TempDir()
	os.WriteFile(filepath.Join(dir, "query.go"), []byte("package cooked\n\nvar X = 1\n"), 0o644)
	os.WriteFile(filepath.Join(dir, "context.go"), []byte("package cooked\n\nvar Y = 2\n"), 0o644)

	outPath := filepath.Join(t.TempDir(), "generated", "pickle.go")
	if err := TickleToFile(dir, "generated", outPath); err != nil {
		t.Fatalf("TickleToFile: %v", err)
	}

	content, err := os.ReadFile(outPath)
	if err != nil {
		t.Fatalf("reading output: %v", err)
	}

	src := string(content)

	// Both files should be present
	if !strings.Contains(src, "var X = 1") {
		t.Error("missing content from query.go")
	}
	if !strings.Contains(src, "var Y = 2") {
		t.Error("missing content from context.go")
	}

	// context.go should come before query.go (alphabetical)
	xIdx := strings.Index(src, "var Y = 2")
	yIdx := strings.Index(src, "var X = 1")
	if xIdx > yIdx {
		t.Error("files should be concatenated alphabetically")
	}
}
