package generator

import (
	"bytes"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"strings"
	"text/template"
)

// ScanCommands parses Go files in the commands directory and returns the names
// of exported types that implement the Command interface (Name(), Description(), Run([]string) error).
func ScanCommands(commandsDir string) ([]string, error) {
	entries, err := os.ReadDir(commandsDir)
	if err != nil {
		return nil, err
	}

	var commands []string

	for _, e := range entries {
		if e.IsDir() || !strings.HasSuffix(e.Name(), ".go") || strings.HasSuffix(e.Name(), "_test.go") {
			continue
		}
		// Skip generated files
		if strings.HasSuffix(e.Name(), "_gen.go") {
			continue
		}

		fset := token.NewFileSet()
		f, err := parser.ParseFile(fset, commandsDir+"/"+e.Name(), nil, 0)
		if err != nil {
			continue
		}

		commands = append(commands, findCommandTypes(f)...)
	}

	return commands, nil
}

// findCommandTypes returns exported type names that have Name() string,
// Description() string, and Run([]string) error methods declared in the file.
func findCommandTypes(f *ast.File) []string {
	// Collect all exported struct type names
	structNames := map[string]bool{}
	for _, decl := range f.Decls {
		gen, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}
		for _, spec := range gen.Specs {
			ts, ok := spec.(*ast.TypeSpec)
			if !ok || !ts.Name.IsExported() {
				continue
			}
			if _, ok := ts.Type.(*ast.StructType); ok {
				structNames[ts.Name.Name] = true
			}
		}
	}

	// Check which structs have all three methods
	methods := map[string]map[string]bool{} // type -> method set
	for _, decl := range f.Decls {
		fn, ok := decl.(*ast.FuncDecl)
		if !ok || fn.Recv == nil || len(fn.Recv.List) == 0 {
			continue
		}

		typeName := receiverTypeName(fn.Recv.List[0].Type)
		if typeName == "" || !structNames[typeName] {
			continue
		}

		switch fn.Name.Name {
		case "Name", "Description", "Run":
			if methods[typeName] == nil {
				methods[typeName] = map[string]bool{}
			}
			methods[typeName][fn.Name.Name] = true
		}
	}

	var result []string
	for name, ms := range methods {
		if ms["Name"] && ms["Description"] && ms["Run"] {
			result = append(result, name)
		}
	}
	return result
}

func receiverTypeName(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.StarExpr:
		if ident, ok := t.X.(*ast.Ident); ok {
			return ident.Name
		}
	}
	return ""
}

var commandsGlueTemplate = template.Must(template.New("commands").Parse(`// Code generated by Pickle. DO NOT EDIT.
package commands

import (
	"database/sql"
	"fmt"
	"log"

	pickle "{{ .HTTPImport }}"
	"{{ .ModelsImport }}"
	"{{ .MigrationsImport }}"
	"{{ .ConfigImport }}"
)

// Ensure imports are used.
var (
	_ = fmt.Sprintf
	_ = log.Fatal
	_ *sql.DB
)

// migrateCommand runs pending migrations.
type migrateCommand struct{}

func (c migrateCommand) Name() string        { return "migrate" }
func (c migrateCommand) Description() string { return "Run pending migrations" }
func (c migrateCommand) Run(args []string) error {
	runner := migrations.NewRunner(models.DB, config.Database.Connection().Driver)
	return runner.Migrate(migrations.Registry)
}

// migrateRollbackCommand rolls back the last batch.
type migrateRollbackCommand struct{}

func (c migrateRollbackCommand) Name() string        { return "migrate:rollback" }
func (c migrateRollbackCommand) Description() string { return "Roll back the last migration batch" }
func (c migrateRollbackCommand) Run(args []string) error {
	runner := migrations.NewRunner(models.DB, config.Database.Connection().Driver)
	return runner.Rollback(migrations.Registry)
}

// migrateFreshCommand drops all tables and re-runs migrations.
type migrateFreshCommand struct{}

func (c migrateFreshCommand) Name() string        { return "migrate:fresh" }
func (c migrateFreshCommand) Description() string { return "Drop all tables and re-run all migrations" }
func (c migrateFreshCommand) Run(args []string) error {
	runner := migrations.NewRunner(models.DB, config.Database.Connection().Driver)
	return runner.Fresh(migrations.Registry)
}

// migrateStatusCommand shows migration status.
type migrateStatusCommand struct{}

func (c migrateStatusCommand) Name() string        { return "migrate:status" }
func (c migrateStatusCommand) Description() string { return "Show migration status" }
func (c migrateStatusCommand) Run(args []string) error {
	runner := migrations.NewRunner(models.DB, config.Database.Connection().Driver)
	statuses, err := runner.Status(migrations.Registry)
	if err != nil {
		return err
	}
	migrations.PrintStatus(statuses)
	return nil
}

// BuiltinCommands returns the built-in Pickle commands.
func BuiltinCommands() []pickle.Command {
	return []pickle.Command{
		migrateCommand{},
		migrateRollbackCommand{},
		migrateFreshCommand{},
		migrateStatusCommand{},
	}
}

// UserCommands returns user-defined commands.
func UserCommands() []pickle.Command {
	return []pickle.Command{
{{ range .UserCommands }}		{{ . }}{},
{{ end }}	}
}

// Commands returns all commands (built-in + user-defined).
func Commands() []pickle.Command {
	return append(BuiltinCommands(), UserCommands()...)
}
`))

// GenerateCommandsGlue produces app/commands/pickle_gen.go.
func GenerateCommandsGlue(modulePath string, migrationsRel string, userCommands []string) ([]byte, error) {
	data := struct {
		HTTPImport       string
		ModelsImport     string
		MigrationsImport string
		ConfigImport     string
		UserCommands     []string
	}{
		HTTPImport:       modulePath + "/app/http",
		ModelsImport:     modulePath + "/app/models",
		MigrationsImport: modulePath + "/" + migrationsRel,
		ConfigImport:     modulePath + "/config",
		UserCommands:     userCommands,
	}

	var buf bytes.Buffer
	if err := commandsGlueTemplate.Execute(&buf, data); err != nil {
		return nil, err
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return buf.Bytes(), err
	}
	return formatted, nil
}
