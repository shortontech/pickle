package generator

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"regexp"
	"sort"
	"strings"
	"text/template"

	"github.com/shortontech/pickle/pkg/names"
)

// MigrationDir describes a directory containing migration files.
type MigrationDir struct {
	Dir        string // absolute path
	ImportPath string // Go import path for this package
}

// MigrationFileEntry pairs a migration ID (filename stem) with the struct name.
type MigrationFileEntry struct {
	ID         string // "2026_02_21_100000_create_users_table"
	StructName string // "CreateUsersTable_2026_02_21_100000"
	ImportPath string // Go import path if from an external package (empty = local)
}

// migrationTimestamp matches the timestamp prefix at the start of a migration filename.
var migrationTimestamp = regexp.MustCompile(`^\d{4}_\d{2}_\d{2}_\d{6}_`)

// migrationTimestampSuffix matches the timestamp suffix in a struct name like
// "CreateUsersTable_2026_02_27_011600".
var migrationTimestampSuffix = regexp.MustCompile(`_(\d{4}_\d{2}_\d{2}_\d{6})$`)

// structNameToMigrationID converts "CreateUsersTable_2026_02_27_011600" to
// "2026_02_27_011600_create_users_table".
func structNameToMigrationID(structName string) string {
	match := migrationTimestampSuffix.FindStringSubmatch(structName)
	if match == nil {
		return ""
	}
	timestamp := match[1]
	namePart := structName[:len(structName)-len(match[0])]
	// Convert PascalCase to snake_case
	snake := names.PascalToSnake(namePart)
	return timestamp + "_" + snake
}

// ScanMigrationFiles scans the migrations directory and returns entries sorted
// by timestamp (filename order), pairing each filename stem with its struct name.
func ScanMigrationFiles(migrationsDir string) ([]MigrationFileEntry, error) {
	entries, err := os.ReadDir(migrationsDir)
	if err != nil {
		return nil, err
	}

	var result []MigrationFileEntry

	for _, e := range entries {
		if e.IsDir() || !strings.HasSuffix(e.Name(), ".go") {
			continue
		}
		if strings.HasSuffix(e.Name(), "_test.go") {
			continue
		}

		// Skip non-migration files (no timestamp prefix and no _gen.go suffix with migrations)
		stem := strings.TrimSuffix(e.Name(), ".go")
		stem = strings.TrimSuffix(stem, "_gen")
		if !migrationTimestamp.MatchString(stem) && !strings.HasSuffix(e.Name(), "_gen.go") {
			continue
		}

		structNames, err := findMigrationStructs(migrationsDir, e.Name())
		if err != nil || len(structNames) == 0 {
			continue
		}

		for _, structName := range structNames {
			// Derive the migration ID from the struct name's timestamp suffix
			id := structNameToMigrationID(structName)
			if id == "" {
				continue
			}
			result = append(result, MigrationFileEntry{
				ID:         id,
				StructName: structName,
			})
		}
	}

	// Sort by ID (timestamp order — filenames already start with YYYY_MM_DD_HHMMSS)
	sort.Slice(result, func(i, j int) bool {
		return result[i].ID < result[j].ID
	})

	return result, nil
}

// ScanAllMigrationFiles scans multiple migration directories and returns a
// merged, timestamp-sorted list of migration entries.
func ScanAllMigrationFiles(dirs []MigrationDir) ([]MigrationFileEntry, error) {
	var all []MigrationFileEntry
	for _, d := range dirs {
		entries, err := ScanMigrationFiles(d.Dir)
		if err != nil {
			return nil, fmt.Errorf("scanning %s: %w", d.Dir, err)
		}
		// Tag entries from external packages with their import path
		for i := range entries {
			entries[i].ImportPath = d.ImportPath
		}
		all = append(all, entries...)
	}
	sort.Slice(all, func(i, j int) bool {
		return all[i].ID < all[j].ID
	})
	return all, nil
}

// findMigrationStructs returns all struct names in a file that embed Migration.
func findMigrationStructs(dir, filename string) ([]string, error) {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, fmt.Sprintf("%s/%s", dir, filename), nil, 0)
	if err != nil {
		return nil, err
	}
	var names []string
	for _, decl := range f.Decls {
		gen, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}
		for _, spec := range gen.Specs {
			ts, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}
			st, ok := ts.Type.(*ast.StructType)
			if !ok {
				continue
			}
			for _, field := range st.Fields.List {
				if len(field.Names) == 0 {
					if ident, ok := field.Type.(*ast.Ident); ok && ident.Name == "Migration" {
						names = append(names, ts.Name.Name)
					}
				}
			}
		}
	}
	return names, nil
}

var registryTemplate = template.Must(template.New("registry").Parse(`// Code generated by Pickle. DO NOT EDIT.
package {{ .Package }}
{{ if .Imports }}
import (
{{ range .Imports }}	{{ .Alias }} "{{ .Path }}"
{{ end }})
{{ end }}
// Registry is the ordered list of migrations for this project.
// Pickle generates this file — do not edit it by hand.
var Registry = []MigrationEntry{
{{ range .Entries }}	{ID: "{{ .ID }}", Migration: &{{ .Qualifier }}{{ .StructName }}{}},
{{ end }}}
`))

type registryEntry struct {
	ID         string
	StructName string
	Qualifier  string // "" for local, "alias." for imported
}

type registryImport struct {
	Alias string
	Path  string
}

// GenerateRegistry produces the contents of migrations/registry_gen.go.
func GenerateRegistry(pkg string, entries []MigrationFileEntry) ([]byte, error) {
	// Determine the "local" import path (the first entry's package, or entries with no special import)
	localImport := ""
	if len(entries) > 0 {
		localImport = entries[0].ImportPath
	}
	for _, e := range entries {
		if e.ImportPath != "" {
			localImport = e.ImportPath
			break
		}
	}

	// Build imports and qualify entries
	seen := map[string]string{} // importPath → alias
	var imports []registryImport
	var regEntries []registryEntry

	for _, e := range entries {
		qualifier := ""
		if e.ImportPath != "" && e.ImportPath != localImport {
			alias, ok := seen[e.ImportPath]
			if !ok {
				// Derive alias from last path segment + "mig" suffix
				parts := strings.Split(e.ImportPath, "/")
				alias = parts[len(parts)-1]
				seen[e.ImportPath] = alias
				imports = append(imports, registryImport{Alias: alias, Path: e.ImportPath})
			}
			qualifier = alias + "."
		}
		regEntries = append(regEntries, registryEntry{
			ID:         e.ID,
			StructName: e.StructName,
			Qualifier:  qualifier,
		})
	}

	data := struct {
		Package string
		Imports []registryImport
		Entries []registryEntry
	}{
		Package: pkg,
		Imports: imports,
		Entries: regEntries,
	}

	var buf bytes.Buffer
	if err := registryTemplate.Execute(&buf, data); err != nil {
		return nil, fmt.Errorf("registry template: %w", err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return buf.Bytes(), fmt.Errorf("go format: %w\n%s", err, buf.String())
	}
	return formatted, nil
}
