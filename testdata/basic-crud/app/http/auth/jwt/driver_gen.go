// Code generated by Pickle. DO NOT EDIT.
package jwt

import (
	"crypto/hmac"
	"crypto/sha256"
	"crypto/sha512"
	"encoding/base64"
	"encoding/json"
	"errors"
	"hash"
	"net/http"
	"strings"
	"time"
	pickle "github.com/shortontech/pickle/testdata/basic-crud/app/http"
)

// Driver implements JWT-based authentication using HMAC signing (HS256/HS384/HS512).
// All crypto uses Go's stdlib â€” no third-party JWT library.
type Driver struct {
	secret    string
	issuer    string
	expiry    int // seconds
	algorithm string
}

// NewDriver creates a JWT auth driver. Config is read from environment:
//   - JWT_SECRET: HMAC signing key (required)
//   - JWT_ISSUER: expected issuer claim (optional)
//   - JWT_EXPIRY: token lifetime in seconds (default: 3600)
//   - JWT_ALGORITHM: HS256, HS384, or HS512 (default: HS256)
func NewDriver(env func(string, string) string) *Driver {
	expiry := 3600
	if v := env("JWT_EXPIRY", ""); v != "" {
		// Simple atoi without importing strconv
		n := 0
		for _, c := range v {
			if c >= '0' && c <= '9' {
				n = n*10 + int(c-'0')
			}
		}
		if n > 0 {
			expiry = n
		}
	}

	return &Driver{
		secret:    env("JWT_SECRET", ""),
		issuer:    env("JWT_ISSUER", ""),
		expiry:    expiry,
		algorithm: env("JWT_ALGORITHM", "HS256"),
	}
}

// Claims represents standard + custom JWT claims.
type Claims struct {
	Subject   string         `json:"sub,omitempty"`
	Issuer    string         `json:"iss,omitempty"`
	ExpiresAt int64          `json:"exp,omitempty"`
	IssuedAt  int64          `json:"iat,omitempty"`
	Role      string         `json:"role,omitempty"`
	Extra     map[string]any `json:"-"`
}

// Authenticate extracts the Bearer token from the request, validates it,
// and returns AuthInfo on success.
func (d *Driver) Authenticate(r *http.Request) (*pickle.AuthInfo, error) {
	h := r.Header.Get("Authorization")
	if !strings.HasPrefix(h, "Bearer ") {
		return nil, errors.New("missing bearer token")
	}
	token := h[7:]
	return d.ValidateToken(token)
}

// SignToken creates a signed JWT from the given claims.
func (d *Driver) SignToken(claims Claims) (string, error) {
	if d.secret == "" {
		return "", errors.New("jwt: secret not configured")
	}

	now := time.Now().Unix()
	if claims.IssuedAt == 0 {
		claims.IssuedAt = now
	}
	if claims.ExpiresAt == 0 && d.expiry > 0 {
		claims.ExpiresAt = now + int64(d.expiry)
	}
	if claims.Issuer == "" && d.issuer != "" {
		claims.Issuer = d.issuer
	}

	alg := d.algorithm
	if alg == "" {
		alg = "HS256"
	}

	header := base64URLEncode([]byte(`{"alg":"` + alg + `","typ":"JWT"}`))

	payload, err := json.Marshal(claims)
	if err != nil {
		return "", err
	}
	payloadEnc := base64URLEncode(payload)

	signingInput := header + "." + payloadEnc
	sig, err := hmacSign([]byte(signingInput), []byte(d.secret), alg)
	if err != nil {
		return "", err
	}

	return signingInput + "." + base64URLEncode(sig), nil
}

// ValidateToken parses and validates a JWT string, returning AuthInfo on success.
func (d *Driver) ValidateToken(tokenStr string) (*pickle.AuthInfo, error) {
	if d.secret == "" {
		return nil, errors.New("jwt: secret not configured")
	}

	parts := strings.SplitN(tokenStr, ".", 3)
	if len(parts) != 3 {
		return nil, errors.New("jwt: malformed token")
	}

	// Verify signature
	signingInput := parts[0] + "." + parts[1]
	sig, err := base64URLDecode(parts[2])
	if err != nil {
		return nil, errors.New("jwt: invalid signature encoding")
	}

	alg := d.algorithm
	if alg == "" {
		alg = "HS256"
	}
	if !hmacVerify([]byte(signingInput), sig, []byte(d.secret), alg) {
		return nil, errors.New("jwt: invalid signature")
	}

	// Decode claims
	claimsJSON, err := base64URLDecode(parts[1])
	if err != nil {
		return nil, errors.New("jwt: invalid payload encoding")
	}
	var claims Claims
	if err := json.Unmarshal(claimsJSON, &claims); err != nil {
		return nil, errors.New("jwt: invalid claims")
	}

	// Check expiry
	if claims.ExpiresAt > 0 && time.Now().Unix() > claims.ExpiresAt {
		return nil, errors.New("jwt: token expired")
	}

	// Check issuer
	if d.issuer != "" && claims.Issuer != d.issuer {
		return nil, errors.New("jwt: invalid issuer")
	}

	return &pickle.AuthInfo{
		UserID: claims.Subject,
		Role:   claims.Role,
		Claims: claims,
	}, nil
}

// --- internal helpers ---

func hmacHashFunc(alg string) func() hash.Hash {
	switch alg {
	case "HS384":
		return sha512.New384
	case "HS512":
		return sha512.New
	default:
		return sha256.New
	}
}

func hmacSign(input, secret []byte, alg string) ([]byte, error) {
	mac := hmac.New(hmacHashFunc(alg), secret)
	mac.Write(input)
	return mac.Sum(nil), nil
}

func hmacVerify(input, sig, secret []byte, alg string) bool {
	expected, _ := hmacSign(input, secret, alg)
	return hmac.Equal(sig, expected)
}

func base64URLEncode(data []byte) string {
	return strings.TrimRight(base64.URLEncoding.EncodeToString(data), "=")
}

func base64URLDecode(s string) ([]byte, error) {
	switch len(s) % 4 {
	case 2:
		s += "=="
	case 3:
		s += "="
	}
	return base64.URLEncoding.DecodeString(s)
}

