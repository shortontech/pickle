package generator

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"text/template"
)

// ControllerMethod describes a single method on a controller.
type ControllerMethod struct {
	Name        string // Method name (e.g. Store)
	RequestType string // Request struct type, empty if context-only
}

// ScanControllers parses all Go files in a directory and returns a map
// of controller name → method name → ControllerMethod.
func ScanControllers(dir string) (map[string]map[string]ControllerMethod, error) {
	entries, err := os.ReadDir(dir)
	if err != nil {
		return nil, fmt.Errorf("reading controllers dir: %w", err)
	}

	result := map[string]map[string]ControllerMethod{}

	for _, e := range entries {
		if e.IsDir() || !strings.HasSuffix(e.Name(), ".go") || strings.HasSuffix(e.Name(), "_test.go") {
			continue
		}

		path := filepath.Join(dir, e.Name())
		src, err := os.ReadFile(path)
		if err != nil {
			return nil, fmt.Errorf("reading %s: %w", path, err)
		}

		fset := token.NewFileSet()
		f, err := parser.ParseFile(fset, path, src, 0)
		if err != nil {
			return nil, fmt.Errorf("parsing %s: %w", path, err)
		}

		for _, decl := range f.Decls {
			fn, ok := decl.(*ast.FuncDecl)
			if !ok || fn.Recv == nil || len(fn.Recv.List) == 0 {
				continue
			}

			// Get the receiver type name (handles *T and T)
			recvType := receiverTypeName(fn.Recv.List[0].Type)
			if recvType == "" {
				continue
			}

			if result[recvType] == nil {
				result[recvType] = map[string]ControllerMethod{}
			}

			cm := ControllerMethod{Name: fn.Name.Name}

			// Check if the method takes a request struct as first param.
			// Pattern: (req SomeRequest, ctx *Context) or (ctx *Context)
			params := fn.Type.Params.List
			if len(params) >= 2 {
				// First param might be a request struct
				firstParamType := paramTypeName(params[0].Type)
				if firstParamType != "" && firstParamType != "Context" && !strings.HasPrefix(firstParamType, "*Context") {
					cm.RequestType = firstParamType
				}
			}

			result[recvType][cm.Name] = cm
		}
	}

	return result, nil
}

func receiverTypeName(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.StarExpr:
		if ident, ok := t.X.(*ast.Ident); ok {
			return ident.Name
		}
	case *ast.Ident:
		return t.Name
	}
	return ""
}

func paramTypeName(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.StarExpr:
		if ident, ok := t.X.(*ast.Ident); ok {
			return "*" + ident.Name
		}
	case *ast.SelectorExpr:
		if pkg, ok := t.X.(*ast.Ident); ok {
			return pkg.Name + "." + t.Sel.Name
		}
	}
	return ""
}

// paramPattern converts Pickle-style :param to Go 1.22+ {param} and collects param names.
var paramPattern = regexp.MustCompile(`:(\w+)`)

func convertPath(picklePath string) (goPath string, params []string) {
	goPath = paramPattern.ReplaceAllStringFunc(picklePath, func(match string) string {
		name := match[1:] // strip leading :
		params = append(params, name)
		return "{" + name + "}"
	})
	return goPath, params
}

// routeTemplateData is the data passed to the route generation template.
type routeTemplateData struct {
	Package    string
	HasBinding bool // whether any route needs JSON decoding
	Handlers   []handlerData
}

type handlerData struct {
	Method      string
	Path        string // Go 1.22+ path with {param}
	Params      []string
	Controller  string
	Action      string
	Middleware  []string
	RequestType string // empty if context-only handler
}

var routeTemplate = template.Must(template.New("routes").Funcs(template.FuncMap{
	"join": strings.Join,
}).Parse(`// Code generated by Pickle. DO NOT EDIT.
package {{ .Package }}

import (
	"net/http"
{{- if .HasBinding }}
	"encoding/json"

	"github.com/go-playground/validator/v10"
{{- end }}
)
{{ if .HasBinding }}
var validate = validator.New()
{{ end }}
// RegisterRoutes wires all route handlers onto the given ServeMux.
func RegisterRoutes(mux *http.ServeMux) {
{{- range .Handlers }}
	// {{ .Method }} {{ .Path }}
	mux.HandleFunc("{{ .Method }} {{ .Path }}", func(w http.ResponseWriter, r *http.Request) {
		ctx := NewContext(w, r)
{{- range .Params }}
		ctx.SetParam("{{ . }}", r.PathValue("{{ . }}"))
{{- end }}
{{- if .Middleware }}
		resp := RunMiddleware(ctx, []MiddlewareFunc{ {{- join .Middleware ", " -}} }, func() Response {
{{- else }}
		resp := RunMiddleware(ctx, nil, func() Response {
{{- end }}
{{- if .RequestType }}
			var req {{ .RequestType }}
			if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
				return ctx.JSON(400, map[string]string{"error": "invalid request body"})
			}
			if err := validate.Struct(req); err != nil {
				return ctx.JSON(422, map[string]string{"error": err.Error()})
			}
			return (&{{ .Controller }}{}).{{ .Action }}(req, ctx)
{{- else }}
			return (&{{ .Controller }}{}).{{ .Action }}(ctx)
{{- end }}
		})
		resp.Write(w)
	})
{{ end -}}
}
`))

// GenerateRoutes produces a Go source file that registers all routes from
// the parsed route definitions onto an http.ServeMux.
func GenerateRoutes(routes []ParsedRoute, controllers map[string]map[string]ControllerMethod, packageName string) ([]byte, error) {
	var handlers []handlerData
	hasBinding := false

	for _, route := range routes {
		goPath, params := convertPath(route.Path)

		h := handlerData{
			Method:     route.Method,
			Path:       goPath,
			Params:     params,
			Controller: route.Controller,
			Action:     route.Action,
			Middleware: route.Middleware,
		}

		// Look up the controller method to see if it takes a request struct
		if methods, ok := controllers[route.Controller]; ok {
			if cm, ok := methods[route.Action]; ok && cm.RequestType != "" {
				h.RequestType = cm.RequestType
				hasBinding = true
			}
		}

		handlers = append(handlers, h)
	}

	// Sort for deterministic output
	sort.Slice(handlers, func(i, j int) bool {
		if handlers[i].Path != handlers[j].Path {
			return handlers[i].Path < handlers[j].Path
		}
		return handlers[i].Method < handlers[j].Method
	})

	data := routeTemplateData{
		Package:    packageName,
		HasBinding: hasBinding,
		Handlers:   handlers,
	}

	var buf bytes.Buffer
	if err := routeTemplate.Execute(&buf, data); err != nil {
		return nil, fmt.Errorf("template execution: %w", err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("go format: %w\n---raw output---\n%s", err, buf.String())
	}

	return formatted, nil
}
