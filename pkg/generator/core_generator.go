package generator

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
)

// GenerateCoreHTTP generates the HTTP types (Context, Response, Router, Middleware, Controller)
// into a single file. This goes into the project root package.
func GenerateCoreHTTP(cookedDir, packageName string) ([]byte, error) {
	skip := map[string]bool{"query.go": true, "scopes.go": true}
	return generateCoreFiles(cookedDir, packageName, skip)
}

// GenerateCoreQuery generates the QueryBuilder[T] and related query types
// into a single file. This goes into the models/ package.
func GenerateCoreQuery(cookedDir, packageName string) ([]byte, error) {
	only := map[string]bool{"query.go": true}
	return generateCoreFilesOnly(cookedDir, packageName, only)
}

// GenerateCore reads the Go source files from pkg/cooked/ (excluding tests,
// build-tagged files, and query/scope machinery), rewrites them into a single
// file with the target package name, and returns the formatted source.
//
// The result is a standalone pickle.go that user projects embed in generated/.
func GenerateCore(cookedDir, packageName string) ([]byte, error) {
	skip := map[string]bool{"query.go": true, "scopes.go": true}
	return generateCoreFiles(cookedDir, packageName, skip)
}

func generateCoreFilesOnly(cookedDir, packageName string, only map[string]bool) ([]byte, error) {
	entries, err := os.ReadDir(cookedDir)
	if err != nil {
		return nil, fmt.Errorf("reading cooked dir: %w", err)
	}

	var paths []string
	for _, e := range entries {
		name := e.Name()
		if e.IsDir() || !strings.HasSuffix(name, ".go") || strings.HasSuffix(name, "_test.go") {
			continue
		}
		if !only[name] {
			continue
		}
		paths = append(paths, filepath.Join(cookedDir, name))
	}
	sort.Strings(paths)

	if len(paths) == 0 {
		return nil, fmt.Errorf("no source files found in %s matching filter", cookedDir)
	}

	return assembleCoreFiles(paths, packageName)
}

func generateCoreFiles(cookedDir, packageName string, skip map[string]bool) ([]byte, error) {
	entries, err := os.ReadDir(cookedDir)
	if err != nil {
		return nil, fmt.Errorf("reading cooked dir: %w", err)
	}

	var paths []string
	for _, e := range entries {
		name := e.Name()
		if e.IsDir() || !strings.HasSuffix(name, ".go") || strings.HasSuffix(name, "_test.go") {
			continue
		}
		if skip[name] {
			continue
		}
		paths = append(paths, filepath.Join(cookedDir, name))
	}
	sort.Strings(paths)

	if len(paths) == 0 {
		return nil, fmt.Errorf("no source files found in %s", cookedDir)
	}

	return assembleCoreFiles(paths, packageName)
}

func assembleCoreFiles(paths []string, packageName string) ([]byte, error) {
	// Two passes per file:
	// 1. AST parse to collect imports and detect build constraints.
	// 2. Text extraction of everything after the import block.
	imports := map[string]string{} // path -> alias
	var bodies []string

	for _, path := range paths {
		src, err := os.ReadFile(path)
		if err != nil {
			return nil, fmt.Errorf("reading %s: %w", path, err)
		}

		fset := token.NewFileSet()
		f, err := parser.ParseFile(fset, path, src, parser.ParseComments)
		if err != nil {
			return nil, fmt.Errorf("parsing %s: %w", path, err)
		}

		if hasBuildConstraint(f) {
			continue
		}

		// Collect imports.
		for _, imp := range f.Imports {
			impPath := strings.Trim(imp.Path.Value, `"`)
			alias := ""
			if imp.Name != nil {
				alias = imp.Name.Name
			}
			if existing, ok := imports[impPath]; !ok || (existing == "" && alias != "") {
				imports[impPath] = alias
			}
		}

		// Extract the body: everything after the package + import block.
		body := stripHeader(string(src))
		body = strings.TrimSpace(body)
		if body != "" {
			bodies = append(bodies, "// --- "+filepath.Base(path)+" ---\n\n"+body)
		}
	}

	// Assemble output.
	var buf bytes.Buffer
	buf.WriteString("// Code generated by Pickle. DO NOT EDIT.\n")
	fmt.Fprintf(&buf, "package %s\n\n", packageName)

	// Consolidated imports.
	if len(imports) > 0 {
		var stdPaths, extPaths []string
		for p := range imports {
			if strings.Contains(p, ".") {
				extPaths = append(extPaths, p)
			} else {
				stdPaths = append(stdPaths, p)
			}
		}
		sort.Strings(stdPaths)
		sort.Strings(extPaths)

		buf.WriteString("import (\n")
		for _, p := range stdPaths {
			writeImportLine(&buf, p, imports[p])
		}
		if len(stdPaths) > 0 && len(extPaths) > 0 {
			buf.WriteString("\n")
		}
		for _, p := range extPaths {
			writeImportLine(&buf, p, imports[p])
		}
		buf.WriteString(")\n\n")
	}

	// Append all bodies.
	for _, b := range bodies {
		buf.WriteString(b)
		buf.WriteString("\n\n")
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("go format: %w\n---raw output---\n%s", err, buf.String())
	}

	return formatted, nil
}

// stripHeader removes the package declaration and import block from Go source,
// returning everything after them.
func stripHeader(src string) string {
	// Remove package line.
	src = regexp.MustCompile(`(?m)^package\s+\w+\s*\n`).ReplaceAllString(src, "")

	// Remove single-line imports: import "foo"
	src = regexp.MustCompile(`(?m)^import\s+"[^"]+"\s*\n`).ReplaceAllString(src, "")

	// Remove grouped imports: import ( ... )
	src = regexp.MustCompile(`(?ms)^import\s*\(.*?\)\s*\n`).ReplaceAllString(src, "")

	return src
}

func writeImportLine(buf *bytes.Buffer, path, alias string) {
	if alias != "" {
		fmt.Fprintf(buf, "\t%s %q\n", alias, path)
	} else {
		fmt.Fprintf(buf, "\t%q\n", path)
	}
}

// hasBuildConstraint checks if a file has a //go:build or +build directive.
func hasBuildConstraint(f *ast.File) bool {
	for _, cg := range f.Comments {
		for _, c := range cg.List {
			if strings.HasPrefix(c.Text, "//go:build ") || strings.HasPrefix(c.Text, "// +build ") {
				return true
			}
		}
	}
	return false
}
