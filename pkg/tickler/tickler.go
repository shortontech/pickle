package tickler

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

var packageLine = regexp.MustCompile(`^package \w+`)

// Tickle reads Go source files from srcDir and returns their contents
// with the package declaration replaced to targetPackage.
// Each file's content is returned as a map of filename â†’ source.
func Tickle(srcDir, targetPackage string) (map[string]string, error) {
	entries, err := os.ReadDir(srcDir)
	if err != nil {
		return nil, fmt.Errorf("reading %s: %w", srcDir, err)
	}

	result := make(map[string]string)

	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		if !strings.HasSuffix(entry.Name(), ".go") {
			continue
		}
		// Skip test files
		if strings.HasSuffix(entry.Name(), "_test.go") {
			continue
		}

		content, err := os.ReadFile(filepath.Join(srcDir, entry.Name()))
		if err != nil {
			return nil, fmt.Errorf("reading %s: %w", entry.Name(), err)
		}

		src := string(content)

		// Replace package declaration
		src = packageLine.ReplaceAllString(src, "package "+targetPackage)

		// Add generated header after package line
		src = strings.Replace(src,
			"package "+targetPackage,
			"// Code generated by Pickle. DO NOT EDIT.\npackage "+targetPackage,
			1,
		)

		result[entry.Name()] = src
	}

	return result, nil
}

// TickleToFile reads all Go source files from srcDir, rewrites their package
// to targetPackage, and concatenates them into a single output file.
func TickleToFile(srcDir, targetPackage, outputPath string) error {
	files, err := Tickle(srcDir, targetPackage)
	if err != nil {
		return err
	}

	// Sort filenames for deterministic output
	var names []string
	for name := range files {
		names = append(names, name)
	}

	// Simple sort
	for i := 0; i < len(names); i++ {
		for j := i + 1; j < len(names); j++ {
			if names[i] > names[j] {
				names[i], names[j] = names[j], names[i]
			}
		}
	}

	var b strings.Builder
	for i, name := range names {
		if i > 0 {
			b.WriteString("\n")
		}
		b.WriteString(files[name])
	}

	if err := os.MkdirAll(filepath.Dir(outputPath), 0o755); err != nil {
		return fmt.Errorf("creating output dir: %w", err)
	}

	return os.WriteFile(outputPath, []byte(b.String()), 0o644)
}
