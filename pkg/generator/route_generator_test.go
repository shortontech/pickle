package generator

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestScanControllers(t *testing.T) {
	dir := filepath.Join("..", "..", "testdata", "basic-crud", "controllers")
	controllers, err := ScanControllers(dir)
	if err != nil {
		t.Fatalf("ScanControllers: %v", err)
	}

	// UserController should exist
	userMethods, ok := controllers["UserController"]
	if !ok {
		t.Fatal("missing UserController")
	}

	// Index should be context-only
	if cm, ok := userMethods["Index"]; !ok {
		t.Error("missing UserController.Index")
	} else if cm.RequestType != "" {
		t.Errorf("Index.RequestType = %q, want empty", cm.RequestType)
	}

	// Store should take CreateUserRequest
	if cm, ok := userMethods["Store"]; !ok {
		t.Error("missing UserController.Store")
	} else if cm.RequestType != "CreateUserRequest" {
		t.Errorf("Store.RequestType = %q, want CreateUserRequest", cm.RequestType)
	}

	// Update should take UpdateUserRequest
	if cm, ok := userMethods["Update"]; !ok {
		t.Error("missing UserController.Update")
	} else if cm.RequestType != "UpdateUserRequest" {
		t.Errorf("Update.RequestType = %q, want UpdateUserRequest", cm.RequestType)
	}

	// PostController
	postMethods, ok := controllers["PostController"]
	if !ok {
		t.Fatal("missing PostController")
	}

	if cm := postMethods["Store"]; cm.RequestType != "CreatePostRequest" {
		t.Errorf("PostController.Store.RequestType = %q, want CreatePostRequest", cm.RequestType)
	}
}

func TestGenerateRoutesBasicCrud(t *testing.T) {
	routesFile := filepath.Join("..", "..", "testdata", "basic-crud", "routes.go")
	src, err := os.ReadFile(routesFile)
	if err != nil {
		t.Fatalf("reading routes.go: %v", err)
	}

	routes, err := ParseRoutes(routesFile, src)
	if err != nil {
		t.Fatalf("ParseRoutes: %v", err)
	}

	controllerDir := filepath.Join("..", "..", "testdata", "basic-crud", "controllers")
	controllers, err := ScanControllers(controllerDir)
	if err != nil {
		t.Fatalf("ScanControllers: %v", err)
	}

	out, err := GenerateRoutes(routes, controllers, "generated")
	if err != nil {
		t.Fatalf("GenerateRoutes: %v", err)
	}

	output := string(out)

	// Should have the generated header
	if !strings.Contains(output, "// Code generated by Pickle. DO NOT EDIT.") {
		t.Error("missing generated header")
	}

	// Should register handlers with Go 1.22+ patterns
	for _, want := range []string{
		`"GET /api/users"`,
		`"GET /api/users/{id}"`,
		`"POST /api/users"`,
		`"PUT /api/users/{id}"`,
		`"DELETE /api/users/{id}"`,
		`"GET /api/posts/"`,
		`"GET /api/posts/{id}"`,
		`"POST /api/posts/"`,
		`"PUT /api/posts/{id}"`,
		`"DELETE /api/posts/{id}"`,
	} {
		if !strings.Contains(output, want) {
			t.Errorf("missing route pattern %s", want)
		}
	}

	// Post routes should have Auth middleware
	if !strings.Contains(output, "Auth") {
		t.Error("missing Auth middleware reference")
	}

	// Store/Update routes should have JSON decoding
	if !strings.Contains(output, "json.NewDecoder") {
		t.Error("missing JSON decoding for request-bound handlers")
	}
	if !strings.Contains(output, "validate.Struct") {
		t.Error("missing validation call")
	}

	// Context-only handlers should call controller directly
	if !strings.Contains(output, ".Index(ctx)") {
		t.Error("missing context-only handler call")
	}

	// Request-bound handlers should pass request struct
	if !strings.Contains(output, ".Store(req, ctx)") {
		t.Error("missing request-bound handler call")
	}

	// Path params should be extracted
	if !strings.Contains(output, `r.PathValue("id")`) {
		t.Error("missing PathValue extraction for :id param")
	}

	// Write the output for inspection
	outputDir := filepath.Join("..", "..", "testdata", "basic-crud", "generated", "routes")
	os.MkdirAll(outputDir, 0o755)
	outPath := filepath.Join(outputDir, "routes_gen.go")
	if err := os.WriteFile(outPath, out, 0o644); err != nil {
		t.Fatalf("writing output: %v", err)
	}
	t.Logf("generated â†’ %s", outPath)
}

func TestConvertPath(t *testing.T) {
	tests := []struct {
		input      string
		wantPath   string
		wantParams []string
	}{
		{"/users", "/users", nil},
		{"/users/:id", "/users/{id}", []string{"id"}},
		{"/users/:userId/posts/:postId", "/users/{userId}/posts/{postId}", []string{"userId", "postId"}},
		{"/", "/", nil},
	}

	for _, tt := range tests {
		goPath, params := convertPath(tt.input)
		if goPath != tt.wantPath {
			t.Errorf("convertPath(%q) path = %q, want %q", tt.input, goPath, tt.wantPath)
		}
		if len(params) != len(tt.wantParams) {
			t.Errorf("convertPath(%q) params = %v, want %v", tt.input, params, tt.wantParams)
		}
	}
}
