package generator

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"regexp"
	"sort"
	"strings"
	"text/template"
)

// MigrationFileEntry pairs a migration ID (filename stem) with the struct name.
type MigrationFileEntry struct {
	ID         string // "2026_02_21_100000_create_users_table"
	StructName string // "CreateUsersTable_2026_02_21_100000"
}

// migrationTimestamp matches the timestamp prefix at the start of a migration filename.
var migrationTimestamp = regexp.MustCompile(`^\d{4}_\d{2}_\d{2}_\d{6}_`)

// ScanMigrationFiles scans the migrations directory and returns entries sorted
// by timestamp (filename order), pairing each filename stem with its struct name.
func ScanMigrationFiles(migrationsDir string) ([]MigrationFileEntry, error) {
	entries, err := os.ReadDir(migrationsDir)
	if err != nil {
		return nil, err
	}

	var result []MigrationFileEntry

	for _, e := range entries {
		if e.IsDir() || !strings.HasSuffix(e.Name(), ".go") {
			continue
		}
		if strings.HasSuffix(e.Name(), "_test.go") {
			continue
		}

		stem := strings.TrimSuffix(e.Name(), ".go")
		// Only process files that start with a timestamp prefix
		if !migrationTimestamp.MatchString(stem) {
			continue
		}

		structName, err := findMigrationStruct(migrationsDir, e.Name())
		if err != nil || structName == "" {
			continue
		}

		result = append(result, MigrationFileEntry{
			ID:         stem,
			StructName: structName,
		})
	}

	// Sort by ID (timestamp order — filenames already start with YYYY_MM_DD_HHMMSS)
	sort.Slice(result, func(i, j int) bool {
		return result[i].ID < result[j].ID
	})

	return result, nil
}

// findMigrationStruct returns the name of the struct in a migration file
// that embeds Migration.
func findMigrationStruct(dir, filename string) (string, error) {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, fmt.Sprintf("%s/%s", dir, filename), nil, 0)
	if err != nil {
		return "", err
	}
	for _, decl := range f.Decls {
		gen, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}
		for _, spec := range gen.Specs {
			ts, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}
			st, ok := ts.Type.(*ast.StructType)
			if !ok {
				continue
			}
			for _, field := range st.Fields.List {
				if len(field.Names) == 0 {
					if ident, ok := field.Type.(*ast.Ident); ok && ident.Name == "Migration" {
						return ts.Name.Name, nil
					}
				}
			}
		}
	}
	return "", nil
}

var registryTemplate = template.Must(template.New("registry").Parse(`// Code generated by Pickle. DO NOT EDIT.
package {{ .Package }}

// Registry is the ordered list of migrations for this project.
// Pickle generates this file — do not edit it by hand.
var Registry = []MigrationEntry{
{{ range .Entries }}	{ID: "{{ .ID }}", Migration: &{{ .StructName }}{}},
{{ end }}}
`))

// GenerateRegistry produces the contents of migrations/registry_gen.go.
func GenerateRegistry(pkg string, entries []MigrationFileEntry) ([]byte, error) {
	data := struct {
		Package string
		Entries []MigrationFileEntry
	}{
		Package: pkg,
		Entries: entries,
	}

	var buf bytes.Buffer
	if err := registryTemplate.Execute(&buf, data); err != nil {
		return nil, fmt.Errorf("registry template: %w", err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return buf.Bytes(), fmt.Errorf("go format: %w\n%s", err, buf.String())
	}
	return formatted, nil
}
