package generator

import (
	"bufio"
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"
)

var migrateTemplate = template.Must(template.New("migrate").Parse(`// Code generated by Pickle. DO NOT EDIT.
package main

import (
	"database/sql"
	"fmt"
	"log"
	"os"

	_ "github.com/jackc/pgx/v5/stdlib"

	"{{ .MigrationsImport }}"
)

func main() {
	dsn := buildDSN()
	db, err := sql.Open("pgx", dsn)
	if err != nil {
		log.Fatalf("opening db: %v", err)
	}
	defer db.Close()
	if err := db.Ping(); err != nil {
		log.Fatalf("connecting to database: %v\nDSN: %s", err, dsn)
	}

	runner := migrations.NewRunner(db, "pgsql")

	cmd := "migrate"
	if len(os.Args) > 1 {
		cmd = os.Args[1]
	}

	switch cmd {
	case "migrate":
		if err := runner.Migrate(migrations.Registry); err != nil {
			log.Fatal(err)
		}
	case "rollback":
		if err := runner.Rollback(migrations.Registry); err != nil {
			log.Fatal(err)
		}
	case "status":
		statuses, err := runner.Status(migrations.Registry)
		if err != nil {
			log.Fatal(err)
		}
		migrations.PrintStatus(statuses)
	case "fresh":
		if err := runner.Fresh(migrations.Registry); err != nil {
			log.Fatal(err)
		}
	default:
		fmt.Fprintf(os.Stderr, "unknown command: %s\n", cmd)
		os.Exit(1)
	}
}

func buildDSN() string {
	host := envOr("DB_HOST", "127.0.0.1")
	port := envOr("DB_PORT", "5432")
	name := envOr("DB_DATABASE", "")
	user := envOr("DB_USERNAME", "postgres")
	pass := envOr("DB_PASSWORD", "")
	return fmt.Sprintf("postgres://%s:%s@%s:%s/%s?sslmode=disable", user, pass, host, port, name)
}

func envOr(key, def string) string {
	if v := os.Getenv(key); v != "" {
		return v
	}
	return def
}
`))

// RunMigrations generates a temporary migrate program, reads .env, and runs it.
func RunMigrations(project *Project, subCmd string) error {
	migrationsImport := project.ModulePath + "/" + project.Layout.MigrationsRel

	var buf bytes.Buffer
	if err := migrateTemplate.Execute(&buf, struct{ MigrationsImport string }{migrationsImport}); err != nil {
		return fmt.Errorf("generating migrate program: %w", err)
	}

	tmpDir := filepath.Join(project.Dir, ".pickle-tmp", "migrunner")
	if err := os.MkdirAll(tmpDir, 0o755); err != nil {
		return fmt.Errorf("creating temp dir: %w", err)
	}
	defer os.RemoveAll(filepath.Join(project.Dir, ".pickle-tmp"))

	runnerPath := filepath.Join(tmpDir, "main.go")
	if err := os.WriteFile(runnerPath, buf.Bytes(), 0o644); err != nil {
		return fmt.Errorf("writing migrate program: %w", err)
	}

	// Load .env from project root
	env := os.Environ()
	dotEnv := parseDotEnv(filepath.Join(project.Dir, ".env"))
	for k, v := range dotEnv {
		if os.Getenv(k) == "" { // existing env vars take precedence
			env = append(env, k+"="+v)
		}
	}

	cmd := exec.Command("go", "run", runnerPath, subCmd)
	cmd.Dir = project.Dir
	cmd.Env = env
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("migrate %s: %w", subCmd, err)
	}
	return nil
}

// parseDotEnv reads a .env file and returns a map of key â†’ value.
func parseDotEnv(path string) map[string]string {
	result := map[string]string{}
	f, err := os.Open(path)
	if err != nil {
		return result
	}
	defer f.Close()

	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}
		idx := strings.IndexByte(line, '=')
		if idx < 0 {
			continue
		}
		key := strings.TrimSpace(line[:idx])
		value := strings.TrimSpace(line[idx+1:])
		if len(value) >= 2 {
			if (value[0] == '"' && value[len(value)-1] == '"') ||
				(value[0] == '\'' && value[len(value)-1] == '\'') {
				value = value[1 : len(value)-1]
			}
		}
		result[key] = value
	}
	return result
}
