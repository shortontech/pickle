package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"sort"
	"text/template"
)

var inspectorTemplate = template.Must(template.New("inspector").Parse(`// Code generated by Pickle. DO NOT EDIT.
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"text/tabwriter"

	"{{ .ModulePath }}/migrations"
)

type columnInfo struct {
	Name             string ` + "`" + `json:"name"` + "`" + `
	Type             string ` + "`" + `json:"type"` + "`" + `
	GoType           string ` + "`" + `json:"go_type"` + "`" + `
	Nullable         bool   ` + "`" + `json:"nullable"` + "`" + `
	PrimaryKey       bool   ` + "`" + `json:"primary_key,omitempty"` + "`" + `
	Unique           bool   ` + "`" + `json:"unique,omitempty"` + "`" + `
	Default          any    ` + "`" + `json:"default,omitempty"` + "`" + `
	ForeignKeyTable  string ` + "`" + `json:"foreign_key_table,omitempty"` + "`" + `
	ForeignKeyColumn string ` + "`" + `json:"foreign_key_column,omitempty"` + "`" + `
	Length           int    ` + "`" + `json:"length,omitempty"` + "`" + `
	Precision        int    ` + "`" + `json:"precision,omitempty"` + "`" + `
	Scale            int    ` + "`" + `json:"scale,omitempty"` + "`" + `
}

type tableInfo struct {
	Name    string       ` + "`" + `json:"name"` + "`" + `
	Columns []columnInfo ` + "`" + `json:"columns"` + "`" + `
	Indexes []indexInfo  ` + "`" + `json:"indexes,omitempty"` + "`" + `
}

type indexInfo struct {
	Columns []string ` + "`" + `json:"columns"` + "`" + `
	Unique  bool     ` + "`" + `json:"unique"` + "`" + `
}

var typeNames = map[migrations.ColumnType]string{
	migrations.UUID:       "uuid",
	migrations.String:     "string",
	migrations.Text:       "text",
	migrations.Integer:    "integer",
	migrations.BigInteger: "biginteger",
	migrations.Decimal:    "decimal",
	migrations.Boolean:    "boolean",
	migrations.Timestamp:  "timestamp",
	migrations.JSONB:      "jsonb",
	migrations.Date:       "date",
	migrations.Time:       "time",
	migrations.Binary:     "binary",
}

var goTypeNames = map[migrations.ColumnType]string{
	migrations.UUID:       "uuid.UUID",
	migrations.String:     "string",
	migrations.Text:       "string",
	migrations.Integer:    "int",
	migrations.BigInteger: "int64",
	migrations.Decimal:    "decimal.Decimal",
	migrations.Boolean:    "bool",
	migrations.Timestamp:  "time.Time",
	migrations.JSONB:      "json.RawMessage",
	migrations.Date:       "time.Time",
	migrations.Time:       "string",
	migrations.Binary:     "[]byte",
}

func processOps(ops []migrations.Operation, tables map[string]*tableInfo, order *[]string) {
	for _, op := range ops {
		switch op.Type {
		case migrations.OpCreateTable:
			ti := &tableInfo{Name: op.Table}
			for _, col := range op.TableDef.Columns {
				goType := goTypeNames[col.Type]
				if col.IsNullable && goType != "[]byte" {
					goType = "*" + goType
				}
				ti.Columns = append(ti.Columns, columnInfo{
					Name:             col.Name,
					Type:             typeNames[col.Type],
					GoType:           goType,
					Nullable:         col.IsNullable,
					PrimaryKey:       col.IsPrimaryKey,
					Unique:           col.IsUnique,
					Default:          col.DefaultValue,
					ForeignKeyTable:  col.ForeignKeyTable,
					ForeignKeyColumn: col.ForeignKeyColumn,
					Length:           col.Length,
					Precision:        col.Precision,
					Scale:            col.Scale,
				})
			}
			tables[op.Table] = ti
			*order = append(*order, op.Table)
		case migrations.OpAddIndex, migrations.OpAddUniqueIndex:
			if ti, ok := tables[op.Table]; ok {
				ti.Indexes = append(ti.Indexes, indexInfo{
					Columns: op.Index.Columns,
					Unique:  op.Index.Unique,
				})
			}
		}
	}
}

func printTable(ti tableInfo) {
	fmt.Printf("\n  %s\n", ti.Name)
	fmt.Println("  " + repeat("─", 70))

	w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)
	fmt.Fprintf(w, "  COLUMN\tTYPE\tGO TYPE\tNULLABLE\tMODIFIERS\n")
	fmt.Fprintf(w, "  ──────\t────\t───────\t────────\t─────────\n")

	for _, col := range ti.Columns {
		mods := ""
		if col.PrimaryKey {
			mods += "PK "
		}
		if col.Unique {
			mods += "UQ "
		}
		if col.Default != nil {
			mods += fmt.Sprintf("default=%v ", col.Default)
		}
		if col.ForeignKeyTable != "" {
			mods += fmt.Sprintf("FK→%s.%s ", col.ForeignKeyTable, col.ForeignKeyColumn)
		}

		nullable := "NO"
		if col.Nullable {
			nullable = "YES"
		}

		fmt.Fprintf(w, "  %s\t%s\t%s\t%s\t%s\n", col.Name, col.Type, col.GoType, nullable, mods)
	}
	w.Flush()

	if len(ti.Indexes) > 0 {
		fmt.Println()
		fmt.Println("  Indexes:")
		for _, idx := range ti.Indexes {
			unique := ""
			if idx.Unique {
				unique = " (unique)"
			}
			fmt.Printf("    %v%s\n", idx.Columns, unique)
		}
	}
	fmt.Println()
}

func repeat(s string, n int) string {
	result := ""
	for i := 0; i < n; i++ {
		result += s
	}
	return result
}

func main() {
	tables := map[string]*tableInfo{}
	var order []string

{{ range .Migrations }}	{
		m := migrations.{{ .StructName }}{}
		m.Up()
		processOps(m.Operations, tables, &order)
	}
{{ end }}
	// Parse args: [--json] [table_name]
	jsonOutput := false
	filter := ""
	for _, arg := range os.Args[1:] {
		if arg == "--json" {
			jsonOutput = true
		} else {
			filter = arg
		}
	}

	var output []tableInfo
	if filter != "" {
		if ti, ok := tables[filter]; ok {
			output = append(output, *ti)
		} else {
			fmt.Fprintf(os.Stderr, "table %q not found\n", filter)
			os.Exit(1)
		}
	} else {
		for _, name := range order {
			output = append(output, *tables[name])
		}
	}

	if jsonOutput {
		enc := json.NewEncoder(os.Stdout)
		enc.SetIndent("", "  ")
		enc.Encode(output)
	} else {
		for _, ti := range output {
			printTable(ti)
		}
	}
}
`))

// MigrationEntry holds info needed to generate the inspector program.
type MigrationEntry struct {
	StructName string
}

// GenerateSchemaInspector produces a temporary Go program that imports the
// project's migrations package, runs each migration's Up() method, and
// outputs the schema as JSON. The migrations package contains tickled copies
// of the schema types — no dependency on pickle.
func GenerateSchemaInspector(modulePath string, migrations []MigrationEntry) ([]byte, error) {
	sort.Slice(migrations, func(i, j int) bool {
		return migrations[i].StructName < migrations[j].StructName
	})

	data := struct {
		ModulePath string
		Migrations []MigrationEntry
	}{
		ModulePath: modulePath,
		Migrations: migrations,
	}

	var buf bytes.Buffer
	if err := inspectorTemplate.Execute(&buf, data); err != nil {
		return nil, fmt.Errorf("template execution: %w", err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return buf.Bytes(), fmt.Errorf("go format: %w\n%s", err, buf.String())
	}

	return formatted, nil
}
